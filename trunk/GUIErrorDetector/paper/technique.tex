\section{Technique}
\label{sec:technique}

We first gives our high-level approach formulation, then present
an error detection algorithm. Finally, we show how to instantiate
the error algorithm to different GUI frameworks.


\subsection{Approach Formulation}

This section formulates our high-level approach. We define the
notations of \textit{UI thread}, \textit{non-UI threads},
\textit{UI accessing methods},
 \textit{Safe methods}, and \textit{invalid thread access error}, and
two assumptions we make with regard to error detection.

\noindent {\textsc{\textbf{Definition 1 (UI Thread).}}} {UI thread
is a special thread created by the GUI framework during
GUI initialization. After the GUI becomes visible, the UI thread
takes charge of the application to handle events from the GUIs,
or spawn new threads to process lengthy operations in the background. }\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 1.}}} {We assume that each multithreaded
GUI application has a single global UI thread. This is true for applications
built on top of GUI frameworks adapting the single-thread rule. The
only exception is that 
 an application may folk a new process to launch another
application with its own UI thread. In that case, we require the new
launched application to be analyzed separately.}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 2 (non-UI Thread).}}} {Any other
threads except for the UI thread in a multithreaded GUI application
 are called non-UI threads.}\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 2.}}} { We assume that each non-UI
thread can only be spawned by the UI thread. Under this assumption,
 all post-initialization
GUI work naturally occurs in the UI-thread. Once the GUI is visible, the
application is driven by events, which are always handled in the UI thread.
We can safely ignore non-UI threads that are spawned during pre-initilaizaiton
GUI work, since if such threads access a GUI object, an exception becomes
immediately apparent and the whole application may abort even before the
GUI is visible. This is highly unlikely for most of the realistic GUI
applications.
}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 3 (UI Accessing Methods).}}} { A method
whose execution may read or write a UI object is called a UI accessing method.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 4 (Safe Methods).}}} {GUI frameworks that
adapt the single-thread rule must provide methods to permit non-UI threads
to run code in the UI thread. We can such methods \textit{safe methods}, since
they can be invoked safely by any threads.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 5 (Invalid Thread Access).}}} {An invalid
thread access error occurs when the UI thread spawns a non-UI thread, and there
exists a path from the non-UI thread's \CodeIn{start} method to any UI accessing methods
without going through any safe methods. }\vspace{2mm}

At a high level, to detect an invalid thread access error, an analysis needs to track all
non-UI threads spawned by the UI thread, and check whether those non-UI threads
may invoke a UI accessing method.

\subsection{Error Detection Algorithm}

The algorithm for detecting potential invalid thread access errors
is shown in Figure~\ref{fig:detectalgorithm}. Our algorithm uses a
static call graph as the program representation for a multithreaded
GUI application. A Java call graph represents calling relationships
between methods. Specially, each node represents a method and each
edge ($f$, $g$) indicates that method $f$ may call method $g$.
A theoretical ideal call graph can be defined as the union of the
dynamic call graphs over all possible executions of the program. 
A conservative static call graph used in practice is a superset of
the ideal call graph; it over-approximates the
dynamic call graph of every possible execution. 
In an object-oriented programming language like
Java, a method is the basic logic unit in a program. Reporting
potential errors at the method level can be sufficient in most cases.
Thus, we believe using call graph is well suited for this problem while
compared with other
program representations like control flow graph or program dependence
graph. 


Our algorithm in Figure~\ref{fig:detectalgorithm} works as follows. It
first constructs a static call graph for the tested program (line 2),
then specifies entry nodes for it (line 3). The algorithm starts to traverse
the call graph from every entry node (line 6). For every entry node,
it first uses Breadth First Search (BFS) to find all reachable
\CodeIn{Thread.start()} method (line 7). Each \CodeIn{Thread.start()} method
indicates that a new, non-UI thread is spawned.  After that, 
the algorithm uses a slightly modified 
BFS algorithm to find reachable UI accessing methods (lines 9 -- 23)
from each \CodeIn{Thread.start()} node.
Specifially, it uses a queue to keep track of all visited nodes, and
then checks every successive node to be visited (line 12);
it reports an error if that node
is a UI accessing method (line 15), or skips it if it is
a safe method (line 17), or simply keeps traversing otherwise (line 19).

If the algorithm determines that a UI accessing method may be invoked
by a non-UI thread, it creates an error report containing the full
method call chain from the entry node (line 15, the \CodeIn{createErrorReport}
method). An example call chain for
the motivating example in Figure~\ref{fig:androiderror} is shown
in Figure~\ref{fig:report}.

Given a sound call graph, our algorithm is sound in that it does not
miss true positives. We note, however, that computing a sound
call graph for partial programs such as an eclipse plugin,
or in the presence of reflection, is non-trivial. 
In particular, GUI applications built on some popular frameworks
often use configuration files and reflection to specify GUI layout
or extension points.
Existing call graph construction algorithms either suffer from incompleteness
or imprecision.  To alleviate this problem, 
We proposed a combined RTA
and k-CFA call graph construction algorithm in Section~\ref{sec:cg}.


We also note that a static analysis may report false positives due
to its conservative nature, or multiple warnings that acutally corrspond to
the same error. In addition, some GUI applications may use
Java native methods to interact with the underlying operating system.
Native methods are often beyond the ability of a static analysis, but
should be considered to construct a good call graph. To address the
above two limitations, we present a set of heuristics to filter
highly likely false positives and remove redundant reports, and provide
annotation support for programmers to specify call relationship for
 native methods.


\begin{figure}[t]
\textbf{Input}: a Java program $P$\\
\textbf{Output}: a set of potential $errors$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE errors $\leftarrow$ $\emptyset$
\STATE cg $\leftarrow$ $constructCallGraph$($P$)
\STATE entryNodes $\leftarrow$ $getEntryNodes$(cg)
\STATE uiAccessNodes $\leftarrow$ $getUIAccessNodes$(cg)
\STATE safeNodes $\leftarrow$ $getSafeNodes$(cg)
\FOR{each entryNode in entryNodes}
\STATE threadStartNodes $\leftarrow$ $getReachableStartsByBFS$(cg)
\FOR{each threadStart in threadStartNodes}
\STATE queue $\leftarrow$ an empty queue
\STATE queue.enqueueAll(threadStart.$getAllSuccNodes$())
\WHILE{queue.isNotEmpty()}
\STATE nextNode $\leftarrow$ queue.dequeue()
\FOR{each succNode in cg.$getSuccNodes$(nextNode)}
\IF{succNode $\in$ uiAccessNodes}
\STATE errors $\leftarrow$ errors $\cup$ $createErrorReport$(succNode)
\ELSIF{succNode $\in$ safeNodes}
\STATE continue
\ELSE
\STATE queue.enqueue(succNode)
\ENDIF 
\ENDFOR
\ENDWHILE
\ENDFOR
\ENDFOR
\RETURN $errors$
%\ENDWHILE
\vspace{-2mm}
\end{algorithmic}
\caption{Algorithm for detecting invalid thread access errors in multithreaded GUI programs. 
Any call graph construction algorithm can be used (line 2).
Three utility methods in lines 3 -- 5 are specific for each GUI framework
 as described in Section~\ref{sec:platforms}.
} \label{fig:detectalgorithm}
\end{figure}


\subsubsection{Call Graph Construction}
\label{sec:cg}


\begin{figure}[t]
%\centering
\begin{CodeOut}
\begin{alltt}

<LinearLayout>
    <Button android:id="@+id/\textbf{button\_id}" android:text="A Button" />
</LinearLayout>

1. public class MyActivity extends Activity \{
2.    final List<View> cachedViews = new LinkedList<View>();
3.    @Override
4.    public void onCreate(Bundle savedInstanceState) \{
5.        super.onCreate(savedInstanceState);
6.        setContentView(R.layout.main);
7.        Button button = (Button) findViewById(R.id.\textbf{button\_id});
8.        button.setOnClickListener(new Button.OnClickListener() \{
9.            @Override
10.           public void onClick(View v) \{
11.               button.setText("Button Clicked.");
12.               cachedViews.add(v);
13.           \}
14.       \});
15.   \}
16. \}
\end{alltt}
\end{CodeOut}
\label{fig:sampleandroid}
\caption{Sample GUI application code on the Android platform. The layout
XML file (the top) specifies a Button object declaratively, 
and the Java code (the bottom)
first loads the XML file (line 6) and then uses reflection to create
a Button object by its ID (line 7, the \CodeIn{findViewByd} method).}
\end{figure}

In the context of object-oriened languages wth dynamic dispatch, the
crucial step in constructing a call graph is to compute a conservative
approximation of the set of methods that can be invoked by a given
virtual method call. Call graph construction algorithms have been
studied intensively in the 1990s. While their original formulations
use a variety of formalisms, most of them can be recast as set-based
analyses. Various algorithms differ primarily in the number of sets
that are used to approximate run-time values of expressions. 
In practice, algorithms such as RTA that use a single set for the whole
program scale well but achieves relatively lower precision. The
k-CFA algorithms maintains one set per expression achieves better
precision than RTA (\textit{k} is the context length, which is
orthogonal to the number of maintained sets).


\begin{figure}[t]
\textbf{Input}: a Java program $P$, a list of classes $cls$\\
\textbf{Output}: a call graph $cg$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE callSiteMap $\leftarrow$ new Map$\langle$CallSite, List$\langle$Type$\rangle$$\rangle$
\STATE rta\_cg $\leftarrow$ $constructCallGraphByRTA$($P$)
\FOR{each $method$ in $P$}
\FOR{each  $callSite$ in $method$}
\STATE type $\leftarrow$ $staticType$(callSite)
\IF{type $\in$ $cls$}
\FOR{each subType of $subType$(type)}
\IF{$hasObjectCreated$(subType, rta\_cg)}
\STATE callSiteMap[callSite].add(subType)
\ENDIF
\ENDFOR
\ENDIF
\ENDFOR
\ENDFOR
\STATE $cg$ $\leftarrow$ $constructCallGraphByKCFA$($P$, callSiteMap)
\RETURN $cg$
%\ENDWHILE
\vspace{-2mm}
\end{algorithmic}
\label{fig:cgalgorithm}
\caption{A combined  RTA~\cite{rta} and k-CFA~\cite{kcfa} call graph construction algorithm.
$cls$ is a list of classes whose method invocations are added to the
call graph using the RTA algorithm; while method invocations from other classes
are added to the call graph using the k-CFA algorithm.
} 
\end{figure}


Unfortunately, GUI applications often use reflection, which makes either
RTA or k-CFA insufficient to build a satisfactory call graph. 
The example code in Figure~\ref{fig:sampleandroid}  illustrates their limitations.
In Figure~\ref{fig:sampleandroid}, line 7 uses reflection to create a \CodeIn{Button}
object by looking up its id declared in the XML file. When this button
is clicked, its event handling code (line 10 -- 13) updates the text and cached
the current view to a list declared at line 2.

Existing call graph algorithms either suffer from the problem of incompleteness
or imprecision. The k-CFA algorithm performs points-to analysis with call
graph construction interleavingly, and maintains a value set for every expression.
For example, it concludes that variable \CodeIn{cachedViews} can only point
to a \CodeIn{LinkedList} object and the method call \CodeIn{add} at line 12
can only correspond to \CodeIn{LinkedList.add}. However, k-CFA fails to
conclude that variable \CodeIn{button} declared at line 7 points to
a \CodeIn{Button} object due to its limitation in dealing with reflection. Thus, k-CFA
may miss the call graph edge corresponding to the method call \CodeIn{setText} at line 11. 
On the other hand, using a coarse-grained algorithm like RTA~\cite{} can not still
fully solve this problem. RTA adds an edge for a method invocation 
to the call graph if an object of the receiver's type (or subtype)
has been created.  By explicitly specifying that all GUI classes declared in the XML file will be created,
RTA maintains a global value set for those GUI object type, and  adds a
call edge \CodeIn{setText} to the call graph. However, RTA introduces 
unnecessary precision loss: it may
may conclude that the \CodeIn{cachedViews} variable at line 2
point to any created \CodeIn{List} objects created somewhere else in the program, despite the
fact that \CodeIn{cachedViews} can only be a \CodeIn{LinkedList} object.


To alleviate the above problems, we present a combined RTA and k-CFA
call graph construction algorithm as shown in Figure~\ref{fig:cgalgorithm}.
The algorithm shares the same spirit as k-CFA to maintain a value set
for each expression. However, the only difference is that our
algorithm uses a RTA-style treatment for constructing the value set for
GUI classes: it parses the XML configuration file and explicitly
adds a raw object to each declared GUI variable's value set. Thus,
For the example in Figure~\ref{fig:sampleandroid}, this
combined algorithm concludes that a \CodeIn{Button} object has been
created at line 7 and then adds the call edge \CodeIn{setText} to the
graph. It also concludes that the \CodeIn{cachedViews} variable can only
point to a \CodeIn{LinkedList} object, avoiding unnecessary precision loss.
%For desktop applications which have main method, it is straigtforward to apply
%the above algorithm. However, for applications on platforms like eclipse plugin
%and Android. presents new challenges. Two technical challenges must be solve.
%First, use reflection extensively, Second, it is possible to interact with
%native code.

%Android features an extended event-based library and dynamic inflation of
%graphical views from declarative XML layout files.
%A static analyzer for Android programs must consider such features, for
%correctness and precision.

%Give an example of how reflection affect call graph precision.


%So, we present a new call graph construction algorithm

%reflected classes are known, use RTA.

%reflection code

%native code


\subsubsection{Heuristic Filtering and Annotation}
\label{sec:heuristic}

A static analysis can exhaustively check possible error path; but may report
paths that do not actually exist (i.e., false positives) or different paths
 that correspond to the same error (i.e., redundant warnings). We devise
a set of heuristics below to filter out likely false positives and redundant warnings.
The first two heuristics are for reducing false positives, while the
remaining ones are for removing redundant warnings.

%To remove those 
%The potentially huge volume of
%reported warnings impose great burden for programmers to check
%its validity. 


\begin{enumerate}

\item \textbf{Filter Reports Containing Library Calls}. A
reported method call chain involving common Library calls
like \CodeIn{Object.toString} or \CodeIn{Runtime.shutDown} are unlikely to
be buggy, and should be filtered. In addition, a method call chain that \textit{only}
consists of library calls after the entry method is also unlikely
to reveal a valid bug, since it has no interaction with the UI. 
We encode a list of common library calls, and remove
a report if it contaiins one of them.
%Method call chain involves typical
%system methods like \CodeIn{toString} are unlikely to reveal a real bug.

\item \textbf{Filter Reports With User-Annotated Methods}. Besides general
library calls, users are also permitted
to explicitly annotate methods that will never trigger an error.
For example, the Android GUI framework provides a utility method 
\CodeIn{runOnUIThread} to check whether the current thread is the UI thread
before executing the code; if
not, it executes the code on the UI thread using message passing.
A reported call chain containing a annotated 
can be safely removed.
%method will never cause an
%invalid thread error and should be removed.

\item \textbf{Filter Lexically Redundant Reports}. One reported method call
chain can lexically subsume another one. For example, suppose that a reported method
call chain \CodeIn{a()} $\rightarrow$ \CodeIn{b()} $\rightarrow$ \CodeIn{c()}
leads to a potential error, and another entry method \CodeIn{d()} calls \CodeIn{a()}.
Therefore, a static analysis might also report another method call chain
\CodeIn{d()} $\rightarrow$ \CodeIn{a()} $\rightarrow$ \CodeIn{b()} $\rightarrow$ \CodeIn{c()}
that actually corresponds to the same error root as the previous one. In this case, 
 removing the second call chain would not reduce the error detection capability:
the first call chain already reveals the same error and is shorter 
for programmers to interpret.


\item \textbf{Filter Report With the Same $k$ Head Methods}. A method can call
multiple methods that access GUI objects, such as:
\begin{CodeOut}
\begin{alltt}
     public void m() \{
         accessUIObject1();
         accessUIObject2();
     \}
\end{alltt}
\end{CodeOut}
If method \CodeIn{m()} is invoked by a non-UI thread, two method call chains
only different at last few method nodes will be reported:

\CodeIn{a()} $\rightarrow$ ...\CodeIn{Thread.start()} ... $\rightarrow$ \CodeIn{m()} $\rightarrow$ \CodeIn{accessUIObject1()} ...

\CodeIn{a()} $\rightarrow$ ...\CodeIn{Thread.start()} ... $\rightarrow$ \CodeIn{m()} $\rightarrow$ \CodeIn{accessUIObject2()} ...

In fact, these two call chains correspond to the same error root: knowning
method \CodeIn{m()} is called by a non-UI thread is sufficient to understand and fix this error.
This filter compares every two reported method call chains that share the same
$k$ ($k$ is user-settable with a default value 5) head nodes, and removes the longer one.

\item \textbf{Filter Report With the Same $k$ Tail Methods}. A method
can have multiple callers, so that method call chains with the same tail are likely
to represent different ways to trigger the same error. This filter compares every
two reported method call chains that share the same 
$k$ ($k$ is user-settable with a default value 5) tail nodes, and removes the longer one.


\end{enumerate}

All above filters are based on heuristics, and thus not sound in
that it may filter real bugs. However, as we will show in
the next experiment section, all these filters work well, and significantly
reduces the number of false positives and redundant reports in practice.

A GUI application may also use native methods to interact with the underlying
operating system or platforms. However, native methods are often
beyond the ability of a static analysis but should be considered to make
the call graph more complete. To do so, we provide an annotation \CodeIn{@CallByNativeMethods}
for users to specify which native methods may call the current method. For example,
the following code snippet indicates that native methods \CodeIn{native1()} and \CodeIn{native2()}
will call method \CodeIn{javaMethod()}.

%\noindent 
\CodeIn{@CallByNativeMethods(callers=\{"native1", "native2"\})}

%\noindent
\CodeIn{public void javaMethod() \{ ... \}}


Our static analysis will take the call relationship as indicated by this
annotation into consideration when traversing the call graph. In our experiment,
we found such an annotation was useful: one real-world bug can only be reported
with the user-provided annotations.

\subsection{Instantiation for Different Frameworks}
\label{sec:platforms}

We instantiate our error detection techniques for four popular GUI frameworks,
namely SWT, Eclipse plugin environment, Swing, and Android.
Each framework has different settings for UI thread (i.e., \textbf{call graph entry nodes}),
\textbf{UI accessing nodes}, and \textbf{safe methods}, which correspond
to lines 3 -- 5 in Figure~\ref{fig:detectalgorithm}. We customize those
framework-specific parts as follows.

%For each framework, we customize the \textit{call graph entry nodes},
%\textit{UI accessing nodes}, and \textit{safe methods} on lines 3 -- 5 of the
%algorithm in 

%For the sake of efficiency, they are all using the single thread model.

%Why these platforms? popularity? account for xxx\% of the GUI. 

%customizing for: entry points, starting points, error checking, thread
%safe methods, what is the event dispatching thread?

\subsubsection{SWT}

SWT is an open source widget toolkit for Java designed to provide efficient,
portable access to the GUI facilities of the operating systems on which it is implemented.
Like a normal Java application, a SWT desktop application has a single main method
as the starting point. By default, the main method launches
the UI thread and pops up the GUI. We instantiate our technique as follows:

%starts from its main method.
%By default, the thread that the main method executes is the UI thread. Thus, we instantiate
%our technique as follows:

\begin{itemize}

\item \textbf{Call graph entry nodes: } the single main method

\item \textbf{UI accessing nodes: } in STW, a thread-unsafe method calls \CodeIn{Display.checkWidget}
or \CodeIn{Display.checkDevice} methods to check whether the current thread is the UI thread or not. Thus,
we treat all such methods that must be accessed in UI thread as the UI accessing nodes.
% any
%methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe methods: } SWT provides two helper methods (\CodeIn{Display.\\asyncExec}
and \CodeIn{Display.syncExec}) as passing (a)synchronized messages to the UI thread.
We treat these two methods as safe methods, since invoking
them from any thread are generally considered to be safe and
would not cause an invalid thread access error.

\end{itemize}

\subsubsection{Eclipse plugin}

An eclipse plugin is an open program. Unlike a SWT desktop application, it does not
have a main method as a single program entry point. Instead, it extends certain
extension points provided by the eclispe framework. As a plugin starts, the eclipse
framework will calls back the overrided extension points and intializes the plugin code.
We customize our technique for eclipse plugin as follows:

%Unlike a SWT desktop application, an eclipse plugin, though is developed in SWT,
%has no single main method. Instead, (XXX) it extends certain extension points
%exposed by the eclipse framework, and eclipse will XXX. To instantiate our
%technique for the Eclipse plugin environment, we need to redefine the
%call graph entry points.

\begin{itemize}

\item \textbf{Call graph entry nodes: } due to the complexity of the eclipse architecture,
there is no rigorous way in eclipse to identify a UI thread. Here, we use a heuristic to determine call graph
entry nodes from the UI thread. As a naming convention, source code in a plugin's \CodeIn{ui}
package deals with the creation and maintainance of a plugin's GUI, and is thus
invoked by the UI thread. We conservatively treat all public methods in the \CodeIn{ui}
as call graph entry nodes.

%entry nodesall overriden methods of the classes inside
% a plugin's \CodeIn{ui} package.  Such methods are normally called by the eclipse framework
%by the UI thread. XXX This rule, though quite heuristical, works quite well in practice.

\item \textbf{UI accessing nodes} and \textbf{Safe methods} are the same as SWT.

\end{itemize}

\subsubsection{Swing}

%The collections classes from the original JDK (\CodeIn{Vector}
%and \CodeIn{Hashtable}) and the AWT library are designed as
%thread-safe. That is, two separate threads of execution can
%access the UI element at the same time without the developer having
%to worry about the threads interfering with one another. However, the
%safety comes at a cost. Because there is a great deal of overhead
%necessary to build thread-safe artifacts, the tend to be much slower
%than nonthread-safe alternatives. 

%The design decisions for Swing changed. This does not mean the controls
%can never be accessed from multiple threads, but the developer is now
%responsible for adding code to ensure that no ill effects occur.

A Swing application has a single main method, but contains three kinds of
threads: \textit{initial thread} that executes initial application code from the main method,
the \textit{UI thread}, where all GUI manipulation code is executed,
and the \textit{worker thread} where time-consuming background tasks are executed.
After a Swing program starts, its initial thread exits and the UI thread takes charge
of the application and starts to execute all event-handling code or spawns new worker threads. 
We customized our technique for Swing as follows:
%XXXX Therefore, we can not directly
%use the main method as the call graph entry point, since it is not invoked
%by the UI thread. We customize our technique for Swing as follows:

\begin{itemize}

\item \textbf{Call graph entry nodes: } all overriden callback methods in the
listerner classes are called from the UI thread. We treat those callback
methods as the entry nodes.

%Specifically, for each class, we check whether
%it is a Swing listerner class. If so, we extract all its overriden callback methods as the call graph entry points.
 %Such methods are normally called by the eclipse framework
%by the UI thread. XXX This rule, though quite heuristical, works quite well in practice.

\item \textbf{UI accessing nodes:} as stated in Swing's documentation, methods
in Swing GUI classes are not thread safe with three exceptions (\CodeIn{repaint()},
\CodeIn{revalidate()}, and \CodeIn{invalidate()}). Thus, we
treat all methods as defined in each GUI class as UI accessing nodes.

\item \textbf{Safe methods: }  Swing provides two helper methods
(\CodeIn{SwingUti-\\lities.invokeLater} and \CodeIn{SwingUtilities.invokeDelay}) to pass messages to the UI thread.
We treat these two methods as safe methods.

\end{itemize}

%A key tasks in instantiating
%our technique to the Swing framework is to identify its event dispatch thread.
%We use

\subsubsection{Android}

Android is a Java-based platform for embedded or mobile devices. 
%Android features an extended event-based library and dynamic inflation of
%graphical views from declarative XML layout files.
Android applications are written in Java, running in their own process within their own virtual machine.
An Android program does not have a single entry point but can
rather use parts of other Android applications on-demand and can require their
services by calling corresponding event handlers, directly or through the
operating system. In particular, Android applications use \textit{activities}
as code interacting with the user through a visual interface. GUI event handlers
are handled in an activity  in no particular ordering.
We instantiate our technique for Android programs as follows:
%, with some notable exceptions such as the
%lifecycle of activities.

%An XML \textit{manifest file} registers the components of an application. Other XML
%fies describe the visual layout of the activities. Activities \textit{inflate}
%layout files into
%visual objects (a hierarchy of views), through an \textit{inflater} provided by the An-
%droid library. This means that library or user-defined views are not explicitly
%created by new statements but rather inflated through \textit{reflection}. Library meth-
%ods such as \CodeIn{findViewById} access the inflated views.


\begin{itemize}

\item \textbf{Call graph entry nodes: } in an Android application,
an \CodeIn{Activity} object is created and manipulated by the UI thread. We treat
all public methods from an \CodeIn{Activity} class as call graph entry nodes. Additionally,
we also add all overriden callback methods in event listener classes as entry nodes.

\item \textbf{UI accessing nodes: } like SWT, Android explicitly checks the current
thread validity before accessing a GUI object using the \CodeIn{ViewRoot.checkThread} method.
Thus, we treat every methods that calls \CodeIn{ViewRoot.checkThread} as a UI accessing node
in the call graph.
%method. This method is the only place where Android checks
%whether the current thread is the UI thread or not. Thus, any
%methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe methods: } Android provides two helper methods (\CodeIn{View.post}
and \CodeIn{View.postDelay}) to execute code on the UI thread. Thus, we treat
these two methods as safe methods, since invoking them on any thread
would not cause an invalid thread access error.
 %Invoking these two methods are generally considered to be safe, and would not
%cause an invalid thread access error.

\end{itemize}


In our experience, instantiating our general technique to  a specific framework
requires moderate human effort. We wrote around 500 lines of Java code in total to achieve
the above four instantiations.
