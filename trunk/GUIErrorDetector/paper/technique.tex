\section{Technique}
\label{sec:technique}

We first gives our high-level approach formulation, then present
an error detection algorithm. Finally, we show how to instantiate
the error algorithm to different GUI frameworks.


\subsection{Approach Formulation}

This section formulates our high-level approach. We define the
notations of \textit{UI thread}, \textit{non-UI threads},
\textit{UI accessing methods},
 \textit{Safe methods}, and \textit{invalid thread access error}, and
two assumptions we make with regard to error detection.

\noindent {\textsc{\textbf{Definition 1 (UI Thread).}}} {UI thread
is a special thread created by the GUI framework during
GUI initialization. After the GUI becomes visible, the UI thread
takes charge of the application to handle events from the GUIs,
or spawn new threads to process lengthy operations in the background. }\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 1.}}} {We assume that each multithreaded
GUI application has a single global UI thread. This is true for applications
built on top of GUI frameworks adapting the single-thread rule. The
only exception is that 
 an application may folk a new process to launch another
application with its own UI thread. In that case, we require the new
launched application to be analyzed separately.}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 2 (non-UI Thread).}}} {Any other
threads except for the UI thread in a multithreaded GUI application
 are called non-UI threads.}\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 2.}}} { We assume that each non-UI
thread can only be spawned by the UI thread. Under this assumption,
 all post-initialization
GUI work naturally occurs in the UI-thread. Once the GUI is visible, the
application is driven by events, which are always handled in the UI thread.
We can safely ignore non-UI threads that are spawned during pre-initilaizaiton
GUI work, since if such threads access a GUI object, an exception becomes
immediately apparent and the whole application may abort even before the
GUI is visible. This is highly unlikely for most of the realistic GUI
applications.
}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 3 (UI Accessing Methods).}}} { A method
whose execution may read or write a UI object is called a UI accessing method.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 4 (Safe Methods).}}} {GUI frameworks that
adapt the single-thread rule must provide methods to permit non-UI threads
to run code in the UI thread. We can such methods \textit{safe methods}, since
they can be invoked safely by any threads.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 5 (Invalid Thread Access).}}} {An invalid
thread access error occurs when the UI thread spawns a non-UI thread, and there
exists a path from the non-UI thread's \CodeIn{start} method to any UI accessing methods
without going through any safe methods. }\vspace{2mm}

At a high level, to detect an invalid thread access error, an analysis needs to track all
non-UI threads spawned by the UI thread, and check whether those non-UI threads
may invoke a UI accessing method.

\subsection{Error Detection Algorithm}

The algorithm for detecting potential invalid thread access errors
is shown in Figure~\ref{fig:detectalgorithm}. Our algorithm uses a
static call graph as the program representation for a multithreaded
GUI application. A Java call graph represents calling relationships
between methods. Specially, each node represents a method and each
edge ($f$, $g$) indicates that method $f$ may call method $g$.
A theoretical ideal call graph can be defined as the union of the
dynamic call graphs over all possible executions of the program. 
A conservative static call graph used in practice is a superset of
the ideal call graph; it over-approximates the
dynamic call graph of every possible execution. 
In an object-oriented programming language like
Java, a method is the basic logic unit in a program. Reporting
potential errors at the method level can be sufficient in most cases.
Thus, we believe using call graph is well suited for this problem while
compared with other
program representations like control flow graph or program dependence
graph. 


Our algorithm in Figure~\ref{fig:detectalgorithm} works as follows. It
first constructs a static call graph for the tested program (line 2),
then specifies entry nodes for it (line 3). The algorithm starts to traverse
the call graph from every entry node (line 6). For every entry node,
it first uses Breadth First Search (BFS) to find all reachable
\CodeIn{Thread.start()} method (line 7). Each \CodeIn{Thread.start()} method
indicates that a new, non-UI thread is spawned.  After that, 
the algorithm uses a slightly modified 
BFS algorithm to find reachable UI accessing methods (lines 9 -- 23)
from each \CodeIn{Thread.start()} node.
Specifially, it uses a queue to keep track of all visited nodes, and
then checks every successive node to be visited (line 12);
it reports an error if that node
is a UI accessing method (line 15), or skips it if it is
a safe method (line 17), or simply keeps traversing otherwise (line 19).

If the algorithm determines that a UI accessing method may be invoked
by a non-UI thread, it creates an error report containing the full
method call chain from the entry node (line 15, the \CodeIn{createErrorReport}
method). An example call chain for
the motivating example in Figure~\ref{fig:androiderror} is shown
in Figure~\ref{fig:report}.

Given a sound call graph, our algorithm is sound in that it does not
miss true positives. We note, however, that computing a sound
call graph for partial programs such as an eclipse plugin,
or in the presence of reflection, is non-trivial. 
In particular, GUI applications built on some popular frameworks
often use configuration files and reflection to specify GUI layout
or extension points.
Existing call graph construction algorithms either suffer from incompleteness
or imprecision.  To alleviate this problem, 
We proposed a combined RTA
and k-CFA call graph construction algorithm in Section~\ref{sec:cg}.


We also note that a static analysis may report false positives due
to its conservative nature, or multiple warnings that acutally corrspond to
the same error. In addition, some GUI applications may use
Java native methods to interact with the underlying operating system.
Native methods are often beyond the ability of a static analysis, but
should be considered to construct a good call graph. To address the
above two limitations, we present a set of heuristics to filter
highly likely false positives and remove redundant reports, and provide
annotation support for programmers to specify call relationship for
 native methods.


\begin{figure}[t]
\textbf{Input}: a Java program $P$\\
\textbf{Output}: a set of potential $errors$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE errors $\leftarrow$ $\emptyset$
\STATE cg $\leftarrow$ $constructCallGraph$($P$)
\STATE entryNodes $\leftarrow$ $getEntryNodes$(cg)
\STATE uiAccessNodes $\leftarrow$ $getUIAccessNodes$(cg)
\STATE safeNodes $\leftarrow$ $getSafeNodes$(cg)
\FOR{each entryNode in entryNodes}
\STATE threadStartNodes $\leftarrow$ $getReachableStartsByBFS$(cg)
\FOR{each threadStart in threadStartNodes}
\STATE queue $\leftarrow$ an empty queue
\STATE queue.enqueueAll(threadStart.$getAllSuccNodes$())
\WHILE{queue.isNotEmpty()}
\STATE nextNode $\leftarrow$ queue.dequeue()
\FOR{each succNode in cg.$getSuccNodes$(nextNode)}
\IF{succNode $\in$ uiAccessNodes}
\STATE errors $\leftarrow$ errors $\cup$ $createErrorReport$(succNode)
\ELSIF{succNode $\in$ safeNodes}
\STATE continue
\ELSE
\STATE queue.enqueue(succNode)
\ENDIF 
\ENDFOR
\ENDWHILE
\ENDFOR
\ENDFOR
\RETURN $errors$
%\ENDWHILE
\vspace{-2mm}
\end{algorithmic}
\caption{Algorithm for detecting invalid thread access errors in multithreaded GUI programs. 
Any call graph construction algorithm can be used (line 2).
Three utility methods in lines 3 -- 5 are specific for each GUI framework
 as described in Section~\ref{sec:platforms}.
} \label{fig:detectalgorithm}
\end{figure}


\subsubsection{Call Graph Construction}
\label{sec:cg}


\begin{figure}[t]
%\centering
\begin{CodeOut}
\begin{alltt}

<LinearLayout>
    <Button android:id="@+id/\textbf{button\_id}" android:text="A Button" />
</LinearLayout>

1. public class MyActivity extends Activity \{
2.    final List<View> cachedViews = new LinkedList<View>();
3.    @Override
4.    public void onCreate(Bundle savedInstanceState) \{
5.        super.onCreate(savedInstanceState);
6.        setContentView(R.layout.main);
7.        Button button = (Button) findViewById(R.id.\textbf{button\_id});
8.        button.setOnClickListener(new Button.OnClickListener() \{
9.            @Override
10.           public void onClick(View v) \{
11.               button.setText("Button Clicked.");
12.               cachedViews.add(v);
13.           \}
14.       \});
15.   \}
16. \}
\end{alltt}
\end{CodeOut}
\label{fig:sampleandroid}
\caption{Sample GUI application code on the Android platform. The layout
XML file (the top) specifies a Button object declaratively, 
and the Java code (the bottom)
first loads the XML file (line 6) and then uses reflection to create
a Button object by its ID (line 7, the \CodeIn{findViewByd} method).}
\end{figure}

In the context of object-oriened languages wth dynamic dispatch, the
crucial step in constructing a call graph is to compute a conservative
approximation of the set of methods that can be invoked by a given
virtual method call. Call graph construction algorithms have been
studied intensively in the 1990s. While their original formulations
use a variety of formalisms, most of them can be recast as set-based
analyses. Various algorithms differ primarily in the number of sets
that are used to approximate run-time values of expressions. 
In practice, algorithms such as RTA that use a single set for the whole
program scale well but achieves relatively lower precision. The
k-CFA algorithms maintains one set per expression achieves better
precision than RTA (\textit{k} is the context length, which is
orthogonal to the number of maintained sets).


\begin{figure}[t]
\textbf{Input}: a Java program $P$, a list of classes $cls$\\
\textbf{Output}: a call graph $cg$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\STATE callSiteMap $\leftarrow$ new Map$\langle$CallSite, List$\langle$Type$\rangle$$\rangle$
\STATE rta\_cg $\leftarrow$ $constructCallGraphByRTA$($P$)
\FOR{each $method$ in $P$}
\FOR{each  $callSite$ in $method$}
\STATE type $\leftarrow$ $staticType$(callSite)
\IF{type $\in$ $cls$}
\FOR{each subType of $subType$(type)}
\IF{$hasObjectCreated$(subType, rta\_cg)}
\STATE callSiteMap[callSite].add(subType)
\ENDIF
\ENDFOR
\ENDIF
\ENDFOR
\ENDFOR
\STATE $cg$ $\leftarrow$ $constructCallGraphByKCFA$($P$, callSiteMap)
\RETURN $cg$
%\ENDWHILE
\vspace{-2mm}
\end{algorithmic}
\label{fig:cgalgorithm}
\caption{A combined  RTA~\cite{rta} and k-CFA~\cite{kcfa} call graph construction algorithm.
$cls$ is a list of classes whose method invocations are added to the
call graph using the RTA algorithm; while method invocations from other classes
are added to the call graph using the k-CFA algorithm.
} 
\end{figure}


Unfortunately, GUI applications often use reflection, which makes either
RTA or k-CFA insufficient to build a satisfactory call graph. 
The example code in Figure~\ref{fig:sampleandroid}  illustrates their limitations.
In Figure~\ref{fig:sampleandroid}, line 7 uses reflection to create a \CodeIn{Button}
object by looking up its id declared in the XML file. Due to
its limitation in handling reflection, the k-CFA algorithm
will conclude that variable \CodeIn{button} at line 7 does not point to any
concrete \CodeIn{Button} object. Thus, it will miss the call edge \CodeIn{setText}
while processing line 11. On the other hand, a less precise algorithm like RTA~\cite{}
can not solve this problem. By explicitly specifying that GUI objects
like \CodeIn{Button} as declared in the XML file will be created, RTA maintains
a global value set for those GUI object type, and concludes that the \CodeIn{button} variable
at line 7 points to a concrete Button object. So the algorithm  adds a
call edge \CodeIn{setText} to the call graph. However, using RTA for
the whole program results in unnecessary precision loss. Note that,
RTA may conclude that the \CodeIn{cachedViews} variable at line 2
may point to any created \CodeIn{List} objects, despite the
fact that \CodeIn{cachedViews} can only be a \CodeIn{LinkedList} object at line 12.


To alleviate the above problems, we present a combined RTA and k-CFA
call graph construction algorithm as shown in Figure~\ref{fig:cgalgorithm}.
This algorithm uses the RTA algorithm to construct call graph for part of the program that
uses reflection to creating GUI objects (to ensure call graph completeness), while still uses
the k-CFA algorithm for the remaining part of the program (to avoid precision loss). Specifically,
users provide a list of classes, which can either be encoded manually or
automatically extracted from the XML configuration file, whose method invocations should be
constructed in a RTA way. The algorithm maintains a global set for
each  provided class, but a separate set for expressions of other
types.  For the example in Figure~\ref{fig:sampleandroid}, this
combined algorithm concludes that a \CodeIn{Button} object has been
created at line 7 and then adds the call edge \CodeIn{setText} to the
graph. It also concludes that the \CodeIn{cachedViews} variable can only
point to a \CodeIn{LinkedList} object, avoiding unnecessary precision loss.

%For desktop applications which have main method, it is straigtforward to apply
%the above algorithm. However, for applications on platforms like eclipse plugin
%and Android. presents new challenges. Two technical challenges must be solve.
%First, use reflection extensively, Second, it is possible to interact with
%native code.

%Android features an extended event-based library and dynamic inflation of
%graphical views from declarative XML layout files.
%A static analyzer for Android programs must consider such features, for
%correctness and precision.

%Give an example of how reflection affect call graph precision.


%So, we present a new call graph construction algorithm

%reflected classes are known, use RTA.

%reflection code

%native code


\subsubsection{Heuristic Filters and Annotations}
\label{sec:heuristic}

Static analysis exhaustively check possible error path; it may report
paths that indicate the same bug. The potentially huge volume of
reported warnings impose great burden for programmers to check
its validity. 

a few useful static heuristic filtering rules.

\begin{itemize}
\item \textbf{Method call chain sumbsumption}. Remove redundant
results

\item \textbf{Remove system calls}. Method call chain involves typical
system methods like \CodeIn{toString} are unlikely to reveal a real bug.

\item \textbf{Method call chain with the same entry}. such
call chains may reveal the same bug

\item \textbf{Method call chain with the same tail}.  different ways
to reach the same bug

\item \textbf{User-defined rules}.  to overcome the limitation

\end{itemize}

The above filtering rules are not sound, it may filter real bugs but works
well in practice.

We also provide annotations for native methods which are beyond the ability
of most static analyses

\subsection{Instantiation for Different Frameworks}
\label{sec:platforms}

We instantiate our error detection techniques for 4 popular GUI frameworks,
namely SWT, Eclipse plugin environment, Swing, and Android.
For each GUI platform, we customize the \textit{call graph entry nodes},
\textit{UI accessing nodes}, and \textit{safe methods} on lines 3 -- 5 of the
algorithm in Figure~\ref{fig:detectalgorithm}.

%For the sake of efficiency, they are all using the single thread model.

%Why these platforms? popularity? account for xxx\% of the GUI. 

%customizing for: entry points, starting points, error checking, thread
%safe methods, what is the event dispatching thread?

\subsubsection{SWT}

SWT is an open source widget toolkit for Java designed to provide efficient,
portable access to the GUI facilities of the operating systems on which it is implemented.

Like normal Java applications, a SWT desktop application starts from its main method.
By default, the thread that the main method executes is the UI thread. Thus, we instantiate
our technique as follows:

\begin{itemize}

\item \textbf{Call graph entry points: } the single main method

\item \textbf{UI accessing nodes: } any methods that calls \CodeIn{org.eclipse.swt.widgets.Display.checkWidget}
or \CodeIn{org.eclipse.swt.widgets.Display.checkDevice} methods, since these two methods are the
only place where the SWT framework checks whether the current thread is the UI thread or not. Thus, any
methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe methods: } SWT provides two utility methods (\CodeIn{Display.asyncExec}
and \CodeIn{Display.syncExec}) that pass messages to the UI thread.
 Invoking these two methods are generally considered to be safe, and would not
cause an invalid thread access error.

\end{itemize}

\subsubsection{Eclipse plugin}

Unlike a SWT desktop application, an eclipse plugin, though is developed in SWT,
has no single main method. Instead, (XXX) it extends certain extension points
exposed by the eclipse framework, and eclipse will XXX. To instantiate our
technique for the Eclipse plugin environment, we need to redefine the
call graph entry points.

\begin{itemize}

\item \textbf{Call graph entry points: } all overriden methods of the classes inside
 a plugin's \CodeIn{ui} package.  Such methods are normally called by the eclipse framework
by the UI thread. XXX This rule, though quite heuristical, works quite well in practice.

\item \textbf{UI accessing nodes} and \textbf{Safe methods} are the same as SWT desktop applications.

\end{itemize}

\subsubsection{Swing}

%The collections classes from the original JDK (\CodeIn{Vector}
%and \CodeIn{Hashtable}) and the AWT library are designed as
%thread-safe. That is, two separate threads of execution can
%access the UI element at the same time without the developer having
%to worry about the threads interfering with one another. However, the
%safety comes at a cost. Because there is a great deal of overhead
%necessary to build thread-safe artifacts, the tend to be much slower
%than nonthread-safe alternatives. 

%The design decisions for Swing changed. This does not mean the controls
%can never be accessed from multiple threads, but the developer is now
%responsible for adding code to ensure that no ill effects occur.

A Swing application often contains three kinds of threads: \textit{initial thread}
that executes initial application code, the \textit{event dispatch thread},
where all GUI manipulation code is executed, and the \textit{worker thread} where
time-consuming background tasks are executed. After Swing UIs are launched,
the initial thread exits and the event dispatch thread starts to execute all
event-handling code or spawns new worker threads. XXXX Therefore, we can not directly
use the main method as the call graph entry point, since it is not invoked
by the UI thread. We customize our technique for Swing as follows:

\begin{itemize}

\item \textbf{Call graph entry points: } all overriden callback methods of the listerner classes.
Specifically, for each class, we check whether it is a Swing listerner class. If so,
we extract all its overriden callback methods as the call graph entry points.
 %Such methods are normally called by the eclipse framework
%by the UI thread. XXX This rule, though quite heuristical, works quite well in practice.

\item \textbf{UI accessing nodes:} unlike SWT, Swing does not explicitly check
whether the current thread is the UI thread or not, when a GUI object is accessed. Except
for three documented thread-safe method (\CodeIn{repaint}, XXXX), our technique
treat all methods defined in each GUI object as UI accessing nodes.

\item \textbf{Safe methods: } similar to SWT, Swing provides two utility methods
(\CodeIn{SwingUtilities.invokeLater} and \CodeIn{SwingUtilities.invokeDelay}) to pass messages to the UI thread. These two methods are regarded as safe methods.

\end{itemize}

%A key tasks in instantiating
%our technique to the Swing framework is to identify its event dispatch thread.
%We use

\subsubsection{Android}

Android is a Java-based platform for embedded or mobile devices. 
Android features an extended event-based library and dynamic inflation of
graphical views from declarative XML layout files. Android applications are
written in Java, running in their own process within their own virtual machine.
Unlike desktop applications, they do not have a single entry point but can
rather use parts of other Android applications on-demand and can require their
services by calling corresponding event handlers, directly or through the
operating system. In particular, Android applications use \textit{activities}
as code interacting with the user through a visual interface. Event handlers
are scheduled in no particular ordering, with some notable exceptions such as the
lifecycle of activities.

An XML \textit{manifest file} registers the components of an application. Other XML
fies describe the visual layout of the activities. Activities \textit{inflate}
layout files into
visual objects (a hierarchy of views), through an \textit{inflater} provided by the An-
droid library. This means that library or user-defined views are not explicitly
created by new statements but rather inflated through \textit{reflection}. Library meth-
ods such as \CodeIn{findViewById} access the inflated views.

We instantiate the technique for Android programs as follows.

\begin{itemize}

\item \textbf{Call graph entry points: } all overriden callback methods of the event
listerner classes, and all overriden callback methods of an Activity. 

\item \textbf{UI accessing nodes: } any methods that calls the \CodeIn{ViewRoot.checkThread}
method. This method is the only place where Android checks
whether the current thread is the UI thread or not. Thus, any
methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe methods: } Android provides two utility methods (\CodeIn{View.post}
and \CodeIn{View.XXX}) that pass messages to the UI thread.
 Invoking these two methods are generally considered to be safe, and would not
cause an invalid thread access error.

\end{itemize}
