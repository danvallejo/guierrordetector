
\tinystep
\section{Empirical Evaluation}
\label{sec:evaluation}

Our experimental objective is three-fold: to demonstrate the effectiveness
of our approach in detecting real errors in multithreaded GUI applications, to 
compare the reflection-aware call graph construction algorithm
with existing ones, and to evaluate the usefulness of the proposed 
error filters.  

First, we describe our subject programs (Section~\ref{sec:subjects}) and the experimental procedure (Section~\ref{sec:procedural}).
We then show that our technique detects bugs in real-world GUI applications (Section~\ref{sec:errors}).
We also compare our technique with
a straightforward approach (Section~\ref{sec:straightforward}),  compare
different call graph construction algorithms (Section~\ref{sec:reflectionaware}), and
evaluate various graph search strategies in error detection (Section~\ref{sec:search}).
 Finally, we show that the proposed filters are effective
in removing warnings (Section~\ref{sec:filters}). 



\subsection{Subject Programs}
\label{sec:subjects}

%library code: 1.4 million

We use a set of open-source projects from Sourceforge, Google code,
and the Eclipse plugin
market as evaluation subjects. To choose subjects for each supported GUI framework,
we first searched for the framework keywords (e.g., ``Java Swing'' or ``Java SWT'')
in the above three source repositories, and then selected subjects based on the following
criteria. First, the subject must be a Java application, not
an open library. Second, the subject must use multithreading in its implementation.
Third, the subject must have undergone at least two years of active development,
and is listed in the first 3 result pages based on popularity. This permits us
to exclude immature subjects that may contain obvious errors.

We chose subjects belonging to various categories from those subjects satisfying
the above criteria. The subjects used in our experiment are shown in Table~\ref{table:subjects},
which include end-user applications, programming tools, and games. 


\begin{itemize}%\addtolength{\itemsep}{-0.5\baselineskip}
\Item \textbf{SWT desktop applications.}
%VirgoFTP~\cite{virgo} and FileBunker~\cite{filebunker} are two useful SWT desktop applications.
VirgoFTP~\cite{virgo} implements a simple FTP client based on Java and SWT UI library.
FileBunker~\cite{filebunker} is a file backup application which uses one or more GMail
accounts as its backup repository. ArecaBackup~\cite{areca} offers a local
file backup solution for Linux and Windows.


\Item \textbf{Eclipse plugins.}
HudsonEclipse~\cite{hudson} monitors Hudson build status from Eclipse.
EclipseRunner~\cite{eclipserunner} extends Eclipse's capability to run launch configurations.


\Item \textbf{Swing applications.} %S3dropbox~\cite{s3dropbox} and SudokuSolver~\cite{sudokusolver} are two Swing desktop applications.
S3dropbox~\cite{s3dropbox}  allows users
to drag and drop files to their Amazon S3 accounts. SudokuSolver~\cite{sudokusolver}
computes Sudoku solutions efficiently using mutlithreading execution. 

\smallstep

\Item  \textbf{Android applications.} %MyTracks~\cite{mytracks}, Fennec~\cite{fennec}, and SGTPuzzles~\cite{sgtpuzzles} are three Android applications.
SGTPuzzler~\cite{sgtpuzzles} is a single-player logic game.
Fennec~\cite{fennec}, developed by Mozilla, is the Mozilla
Firefox web browser for mobile devices. 
MyTracks~\cite{mytracks}, developed by Google, records users' GPS tracks, and provides
interfaces to visualize them on Google Maps. 

\end{itemize}


\begin{table}[t]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\hspace*{-0.2cm}
\setlength{\tabcolsep}{.70\tabcolsep}
\begin{tabular}{|p{4.4cm}||c|c|c|c|}
\hline
 Program (version) & LOC & Classes & Methods \\
\hline \hline
\multicolumn{4}{|l|}{SWT desktop applications}   \\
 \hline
 VirgoFTP (1.3.5) &  10815 &  116 &  1955\\
 \hline
 FileBunker (1.1.2)&  14237 &  150 &  1106  \\
 \hline
 ArecaBackup (7.2)&   23226 &  444 &  4729 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Eclipse plugins}   \\
 \hline
 EclipseRunner (1.1.0) &  3101 &  48 &  354\\
 \hline
 HudsonEclipse(1.0.9)&  11077 &  74 &  649 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox (1.7) &  2353 &  42  &  224 \\
 \hline
 SudokuSolver (1.06)&  3555 &  10 &  62 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler (v9306.11)&  2220 &  16 &  148 \\
 \hline
 Fennec (10.0.a.rc3)&  8577 &  51 &  620 \\
 \hline
 MyTracks (1.1.13.rc4)&  20297 &  143 &  1374 \\
\hline
\hline
 Total &  99458 &  1094 &  11221 \\
\hline
\multicolumn{4}{l}{}   \\
\hline
 GUI framework (version) & LOC & Classes & Methods  \\
\hline \hline
 SWT (3.6)&  129942 &  999 &  9643 \\
\hline
 Eclipse plugin development (3.6.2)&  460830 &  6630 &  37183 \\
\hline
Swing (1.6)&  167961 &  878 &  13159 \\
\hline
 Android (3.2)&  683289 &  5085 &  10584 \\
\hline
\hline
 Total &  1442022 &  13592 &  70569\\
\hline
\end{tabular}

\end{center}
\vspace{-15pt}
\Caption{{\label{table:subjects} Open source programs
used in our evaluation. Column ``LOC'' is the number of non-blank, non-comment lines
of code, as counted by LOCC~\cite{locc}.  Each program is analyzed
together with its GUI framework, as listed in
the bottom table.} }
\end{table}

\smallstep
\tinystep

\subsection{Experimental Procedure}
\label{sec:procedural}

We ran our tool on each subject with three call graph construction
algorithms: RTA~\cite{rta}, 0-CFA, and 1-CFA~\cite{kcfa}.  When running
each call graph construction algorithm on three Android applications, we
used two configurations: with and without the reflection-aware algorithm 
(Section~\ref{sec:cg}).  We did not use more expensive algorithms like $k$-CFA ($k >$ 1),
because they can not scale to our subject programs.

We first inspected the source code of each subject to determine whether any
native methods or project-specific GUI interaction patterns were implemented.
Only SGTPuzzler uses native methods to interact with
the underlying operating system. Thus, we manually checked the possible
Java methods that a native method may call, and then added \annotationnum \CodeIn{@CalledByNativeMethods}
annotations for it. Two subjects MyTracks and Fennec employ a customized pattern
to interact with the GUI framework. For example, in MyTracks, all non-UI
threads are initialized via using the library method \CodeIn{android.os.} \CodeIn{handler.handleCallback}.
% the \CodeIn{safeInvokeXX}
%method in the XXX subject first checks whether the current thread is the UI-thread, and
%then determines whether to direct access a GUI object or wrap the code with
%message passing. 
Thus, we add \filternum user-defined filters for these two subjects.
%to indicate
%that they are safe to be invoked from any thread. 
In this experiment, none of the paper
authors was familiar with the subjects; but we found it is quite easy
to add extra annotations and user-defined filters. All these
manual parts took less than a total of 60 minutes.

For each output
warning, we manually determined its validity by either searching the
bug repository to check whether the same error has been reported before,
or submitting a new bug report, or writing a test driver to reproduce
the error.



\begin{table*}[ht]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\hspace*{-0.2cm}
\setlength{\tabcolsep}{.15\tabcolsep}
\begin{tabular}{|l||c|c|c||c|c|c||c|c|c||c|}
\hline
 Subject&  \multicolumn{9}{|c||}{Our Technique} & Requiring Wrappers  \\
\cline{2-10}
 Program  &  \multicolumn{3}{|c||}{RTA }& \multicolumn{3}{|c||}{0-CFA } & \multicolumn{3}{|c||}{1-CFA } & (Section~\ref{sec:straightforward})  \\
\cline{2-11}
 & CG Size & \#Warning & \#Bug & CG Size & \#Warning & \#Bug & CG Size & \#Warning & \#Bug & \#Warning \\
\hline \hline
\multicolumn{11}{|l|}{SWT desktop applications}   \\
 \hline
 VirgoFTP&  12401 &  1 &  1 & 10858 & 1 & 1 & 43598 & 2 & 2& 149  \\
 \hline
 FileBunker &  18951 &  1 &  0 & 15743 & 0 & 0 & 76088 & 2 & 1& 693  \\
 \hline
 ArecaBackup&  20882 &  1  &  0 & 19697 & 1 & 1  & 116398 & 1 & 1 & 3021\\
 \hline
 \hline
\multicolumn{11}{|l|}{Eclipse plugins}   \\
 \hline
 EclipseRunner&  11248&  6 &  1 & 7201 & 6 & 1 & 26911 & 6 & 1& 202  \\
 %\hline
 %FileSync&  12132 &  xx &  xxx &8235 & xx & xx& 32565 & 1 & 1 & 331 & 1 \\
 \hline
 HudsonEclipse& 18473 &  2 &  1 & 15814 & 2 & 1& 56645 & 3 & 1 & 182 \\
 \hline
 \hline
\multicolumn{11}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox & 37751 &  0 &  0 & 30609 & 0 & 0 & 115324 & 1 & 1 & 210  \\
 \hline
  SudokuSolver&  27730&  3 &  2 & 20907 & 3 & 2 & 39299 & 2 & 2 & 356  \\
 \hline
 \hline
\multicolumn{11}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler & 13631 / 13865&  12 / 16 &  0 / 0 & 9546 / 9682& 4 / 4& 1 / 1 & 35198 / 35756 & 1 / 1  & 1 / 1& 104 \\
 \hline
 Fennec & 14058 / 14387 &  1 / 1 &  0 / 0 & 8263 / 8898 & 1 / 1 & 0 / 0& 29125/ 31759 & 3 / 3 & 1 / 1& 433 \\
 \hline
 MyTracks & 24036 / 24036 &  161 / 220 & 0 / 0 & 10803 / 13645 & 119 / 119 & 0 / 0 & 39235 / 110977 & 1 / 1 & 0 / 1 & 1192 \\
\hline
\hline
 Total & 199161 / 199724 &  188 / 251 & 5 / 5 & 149441 / 153054& 137 / 137& 6 / 6 & 577821 / 652756& 22 / 22 & 11 / 12 & 6542\\
\hline
\end{tabular}
\end{center}
\vspace{-15pt}
\Caption{{\label{table:results}Experimental results in finding invalid thread access errors
in multithreaded GUI programs. Column ``CG Size'' shows the
call graph size in terms of node number. Column ``\#Warning''
shows the number of warnings issued by our tool. Column ``\#Bug'' shows
the actual bugs found. Columns ``RTA '', ``0-CFA'',
and ``1-CFA'' show the results of using different
call graph construction algorithms. In each cell of the table
for Android applications, a slash ``/'' separates the result of
using standard call graph construction algorithm and the reflection-aware
call graph construction algorithm. The \newbugs errors found in VirgoFTP, FileBunker, ArecaBackup
S3dropbox, and SudokuSolver are previously  unknown. As a comparison, the
results of the ``Requiring Wrappers'' approach (Section~\ref{sec:straightforward}),
are shown at the far right.} }
\end{table*}

\tinystep
\subsection{Results}
\label{sec:results}

%Table~\ref{table:results} show the errors in
%our subject programs, and Table~\ref{table:filters} show
%the effect of applying each heuristic filter.
\smallstep

\subsubsection{Errors in Multithreaded GUI Applications}
\label{sec:errors}

As shown Table~\ref{table:results},  our tool found
real errors in each subject program. Using the 1-CFA
call graph algorithm, our tool issued 22 warnings, among
which \bugs warnings reveal \bugs distinct errors (\newbugs are previously unknown),
2 warnings are false positives, and the remaining 8 warnings
are redundant. Section~\ref{sec:reflectionaware} compares with other call graph
construction algorithms.

We submitted all \newbugs new errors
to the subject developers. As of Feb 2012, 1 error in S3dropbox has been confirmed,
4 errors have been reproduced and validated in our own experimental environment, and
2 errors in FileBunker and ArecaBackup had not been verified by developers yet.



\begin{figure}[t]
\hspace{4mm}\small{In class: com.tomczarniecki.s3.gui.DeleteBucketAction}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
59.private void deleteBucket() \{
60.    executor.execute(new Runnable() \{
61.        public void run() \{
62.            try \{
63.                controller.deleteCurrentBucket();
64.            \} catch (Exception e) \{
65.                logger.info("Delete failed", e);
66.                deleteError(); 
67.            \}
68.       \}
69.    \});
70.\}

77.private void deleteError() \{
78.    String text = "Cannot delete folder .....";
79.    display.showErrorMessage("Delete failed", 
        String.format(text, controller.getSelectedBucketName())); 
80.\}
\smallstep
\end{alltt}
\end{CodeOut}
\smallstep
\vspace*{-2.0ex} \Caption{{\label{fig:swingerror} An
invalid thread access error reported by our tool
in the S3dropbox Swing application. The error occurs when
the method \CodeIn{deleteCurrentBucket} invoked on line 63 throws
an exception, which causes method \CodeIn{deleteError} to
access a Swing GUI object \CodeIn{display} on line 79 from
a non-UI thread. This error is previously unknown, and has been confirmed by the S3dropbox developers.
}} %\vspace{-5mm}
\end{figure}

%Figures~\ref{fig:swingerror} amd~\ref{fig:pluginerror} show
%two real errors our tool has found. 
Figure~\ref{fig:swingerror}
shows an invalid thread access error our tool found in S3dropbox.
This error happens when the \CodeIn{deleteCurrentBucket}
call on line 63 throws an exception, making it hard to
detect by testing. We reported this error to the S3dropbox developers. Tom Czarniecki,
a key developer of S3dropbox, confirmed this single-GUI-thread
violation. He mentioned that the S3dropbox project uses
certain design patterns to avoid such violations (e.g.,
actions for UI interaction are encapsulated into a \CodeIn{Worker} interface),
but they still overlooked  the error our tool found.
Another reason they overlooked this violation is because some GUI frameworks like Swing
do not provide any run-time checks for invalid thread accesses. Swing
GUI might not exhibit user-visible faults on many erreoneous executions.
However, as clearly stated in the official documentation~\cite{swing}, %Swing is a single-GUI-threaded GUI toolkit and
accessing Swing GUI objects from non-UI threads risks thread interference
or memory-consistency errors.



\begin{figure}[t]
\hspace{4mm}\small{In class: com.eclipserunner.views.impl.RunnerView}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt} 
179.private void initializeResourceChangeListener() \{
180.  ResourcesPlugin.getWorkspace().addResourceChangeListener(
        new IResourceChangeListener() \{
181.      public void resourceChanged(IResourceChangeEvent event) \{
182.        refresh();
183.      \}
184.  \}, IResourceChangeEvent.POST\_CHANGE);
185.\}

414.public void refresh() \{
415.  getViewer().refresh();
416.\}
\end{alltt}
\end{CodeOut}
\smallstep
\vspace*{-2.0ex} \Caption{{\label{fig:pluginerror} An
invalid thread access error reported by our tool
for the EclipseRunner plugin. In Eclipse, the
callback method \CodeIn{resourceChanged} on line 181
is invoked by non-UI threads when a \CodeIn{ResourceChangeEvent}
happens. However, the \CodeIn{refresh} method directly accesses
GUI objects (to refresh the view on line 415) without any
protection and thus triggers the error.
This error has been reported by other users 13 months after the
buggy code was checked in, and fixed by developers.
}} %\vspace{-5mm}
\end{figure}

Figure~\ref{fig:pluginerror} shows an error found in the EclipseRunner
plugin. This error is event-related. It happens when a 
\CodeIn{ResourceChangeEvent} happen, which then invokes the \CodeIn{refresh}
method on line 415 to update the user interface. In EclipseRunner,
the \CodeIn{refresh} method is
called by 6 different methods from the same non-UI thread. Thus, our
tool issues 6 separate warnings to indicate
6 different ways to trigger this error. 5 of the warnings are redundant.

Besides the above two examples, other errors our tool reported are also
subtle to find. For example, our tool found two new errors in SudokuSolver.
One error only happens when
the given Sudoku is unsolvable; and the other one happens
when  JVM fails to launch the mail composing window of the
user default mail client (after a user clicks the "eMail Me" button).

As reflected in our experiments, we found GUI developers have already
used design patterns, runtime checks, and testing to avoid violating
the single-GUI-thread rule. However, due to the huge space of
possible UI interactions, potential
invalid thread access errors still exist in many corner cases and
can be hard to find. 
%Thus, a static analysis as presented in this paper
%would be useful.


\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our technique can find real errors
in multithreaded GUI applications with
acceptable accuracy.

\subsubsection{Comparison to Requiring Wrappers}
\label{sec:straightforward}

As briefly mentioned in Section~\ref{sec:finding}, one way to prevent
invalid thread access errors is to wrap every GUI-accessing operation
with message passing (i.e., via the safe UI methods). Although
this approach can give rise to other types of errors, a
straightforward way to detect potential invalid thread access errors
is to issue a warning whenever a GUI-accessing operation
is not wrapped. 

As shown in the far right column of ``Requiring Wrappers'' in
Table~\ref{table:results}, Requiring Wrappers could identify every
error that our technique found, but it issued a huge number of warnings,
most of which are probably false positives.
The primary reason is that this simple approach
does not globally reason about the calling relationship between
threads, UI-accessing methods, and safe UI methods, and thus it often incorrectly
classifies GUI accessing operations which will never be executed
in a non-UI thread as erroneous. Furthermore, our technique
outputs a method call chain with each reported error, which can help
developers understand how an invalid thread access error is triggered.



\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our technique provides
richer contextual information for the reported error, and 
is significantly more precise than requiring each GUI
access to be wrapped.

\subsubsection{Comparing Call Graph Construction Algorithms}
\label{sec:reflectionaware}

We next compare the three call graph construction algorithms (RTA, 0-CFA, and 1-CFA)
used in our experiments. As shown in Table~\ref{table:results},  1-CFA found
more errors with fewer false positive warnings than the other two algorithms. This
is because RTA and 0-CFA do not consider the calling context when
constructing a call graph, and may
mix the same method calls by different callers into a single node, thus
introducing imprecision. Although the error-revealing paths exist in
less precise graphs, the impreicison prevents our algorithm finding them.
Figure~\ref{fig:ex} illustrates this point.

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.45]{cgexample}
  \vspace*{-5.0ex}\caption {{\label{fig:ex} (a) shows an example code, in which
\CodeIn{safe()} is a Safe UI method, and \CodeIn{uiAcc()} is a UI-Accessing method.
(b) shows a less precise call graph built by RTA or 0-CFA, and (c) shows a more
precise call graph built by 1-CFA. Nodes for constructors are omitted for brevity.
Using the less precise call graph, the error
detection algorithm in Figure~\ref{fig:detectalgorithm} will report an invalid method call chain: \CodeIn{entry()}
$\rightarrow$ \CodeIn{f()} $\rightarrow$ \CodeIn{start()} $\rightarrow$ \CodeIn{run()}
$\rightarrow$ \CodeIn{uiAcc()},
but miss the actual error path: \CodeIn{entry()} $\rightarrow$ \CodeIn{g1()} $\rightarrow$
\CodeIn{g2()} $\rightarrow$ \CodeIn{start()} $\rightarrow$ \CodeIn{run()} $\rightarrow$ \CodeIn{uiAcc()}. The
actual error path can only be found when using the more precise call graph.
}}
\end{figure}



The results in Table~\ref{table:results} also show that using a reflection-aware
call graph construction algorithm helps in finding errors in Android
applications. One error from the MyTracks Android application
can only be found by using the reflection-aware call graph construction algorithm.
This is because the error-related GUI object (\CodeIn{msgTextView}) in MyTracks is created
reflectively as follows.

{\vspace{2mm}
\hspace{3mm}\small{In class: com.google.android.apps.mytracks.StatsUtilities}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
97.  public void setLatLong(int id, double d) \{
98.     TextView msgTextView = (TextView) activity.\textbf{findViewById}(id);
99.     msgTextView.setText(LAT\_LONG\_FORMAT.format(d));
100. \}
\end{alltt}
\end{CodeOut}}

 
Errors in the other two Android applications (Fennec and SGTPuzzler)
can be found by using a standard call graph construction algorithm.
This is because the error-related GUI objects are created explicitly,
so the standard call graph construction algorithm is sufficient.

%Without
%replacing the reflection calls with explicit object creation instructions,
%a call graph construction algorithm will
%conclude that no GUI object has been created, and thus miss many UI-related
%edges in the resulting graph.

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Using the 1-CFA 
algorithm finds more errors than 0-CFA and RTA, and our reflection-aware call
graph construction algorithm helps to find errors on some
Android applications.

\subsubsection{Comparing Graph Search Strategies}
\label{sec:search}

Our error detection algorithm in Figure~\ref{fig:detectalgorithm} uses BFS to search for
potential single-GUI-thread violations. However, other graph search strategies such as
Depth-First Search (DFS) and exhaustive path search can also be employed. To
understand trade-offs between using different search strategies, we 
implemented two variants of the algorithm in Figure~\ref{fig:detectalgorithm}, and
evaluated them on the same subjects with the identical environment settings.

The first variant uses DFS for graph traversal by changing
line 8 in Figure~\ref{fig:detectalgorithm} to:
$\mathit{worklist}$ $\leftarrow$ $\mathit{an}$ $\mathit{empty}$ $\mathit{stack}$,
and changing queue operations (\CodeIn{enqueueAll}, and \CodeIn{dequeue}
on lines 9, 12, and
23 in Figure~\ref{fig:detectalgorithm}, respectively)
to the corresponding statck operations (\CodeIn{pushAll}, and \CodeIn{pop}).
This variant found 11 errors in total and missed 1 error in the FileBunker subject.
The reason is that DFS tends to search deeper into the graph, and the path it returns
may not be the shortest one and is more likely to be an infeasible path in practice.
%For the FileBunker subject, paths
%returned by DFS are much longer than BFS, and do not actually exist.

%Hundson: 3, 1
%EclipseRunner: 6, 1
%S3dropbox: ? , ?  too many warnings time: 31678 (45528 chains), running out of memory
%SudokuSolver:  2, 1 too many warnings: 1700, 2090
%VirgoFTP: 2, 2
%FileBunker:  2, 0  //very long method calls
%Fennec: 3, 1
%SGTPuzzler: 1, 1
%MyTracks: 1, 1

The second variant uses exhaustive search to find potential errors. This variant
enumerates all non-cyclic paths from all reachable \CodeIn{Thread.start()} nodes
to each UI-accessing node, and then checks whether each
path spawns a new thread and accesses GUI objects without using safe UI methods.
This variant ran out of memory on all subjects. We checked
the explored paths before the algorithm terminated, and found none of them
revealed a real error. This is because the number of
non-cyclic paths in a graph is exponential in the graph size.%node number.
For a realistic call graph which often contains thousands of nodes,
it is infeasible to enumerate all paths.
%only a very few amount of paths can be enumerated within a practical amount of time.


\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Using BFS finds more errors than DFS and
exhaustive search in our error detection algorithm. 


\subsubsection{Evaluating Error Filters}
\label{sec:filters}

Table~\ref{table:filters} measures the effectiveness of the proposed 
error filters of Section~\ref{sec:heuristic}.
The five error filters removed 99.96\% of the reported warnings as false positives
or redundant warnings. Specifically, two sound filters 1 and 2 
removed 34.44\% of the warnings, and three heuristic filters 3, 4, and 5
removed a further 65.52\% of the warnings. Among them, the 4th filter for removing
reports with the same head methods from the entry node to \CodeIn{Thread.start()}
is the most effective one. 

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Although a static analysis may
issue false positives or redundant reports, a set of well-designed
error filters can remove most of them.
%Heuristic filter, effective.

\begin{table}[t]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\setlength{\tabcolsep}{.46\tabcolsep}
\hspace*{-0.2cm}
\begin{tabular}{|l||c|c|c|c|c|c|}
\hline
 & \multicolumn{6}{|c|}{Number of Warnings}  \\
\cline{2-7}
 Subject & Before & \multicolumn{2}{|c|}{Sound Filters}  &  \multicolumn{3}{|c|}{Heuristic Filters}  \\
\cline{3-7}
 Program &Filtering  & $F_1$ & $F_{1,2}$ & $F_{1,2,3}$&$F_{1,2,3,4}$ & $F_{1,2,3,4,5}$\\
\hline \hline
\multicolumn{7}{|l|}{SWT desktop applications}   \\
 \hline
 VirgoFTP &  21 &  21 &  21 & 7 &  2 & 2\\
 \hline
 FileBunker &  4494 &  4494 &  4494 &  3210 &  10  & 2\\
 \hline
 ArecaBackup &  6219 &  438 & 438 &  438  &  1 & 1\\
 \hline
 \hline
\multicolumn{7}{|l|}{Eclipse plugins}   \\
 %\hline
 %EclipseRunner &  xxxx &  xx &  xxx & xx &  xxx & xx\\
 \hline
 EclipseRunner&  1644 &  1644 &  1644 & 1644 &  6 & 6\\
 \hline
 HundsonEclipse&  1367 &  567 &  567 & 567 &  3 & 3\\
 \hline
 \hline
\multicolumn{7}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox&  45528 &  31978 &  31978 & 30975 &  9 & 1\\
 \hline
 SudokuSolver &  58 &  58 &  58 & 58  &  2 & 2\\
 \hline
 \hline
\multicolumn{7}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler&  2 &  1 &  1 & 1 &  1 & 1\\
 \hline
 Fennec &  122 &  84 & 80 & 80 &  9 & 3\\
 \hline
 MyTracks &  1176 &  1176 &  483 & 441 &  69 & 1 \\
\hline
 \hline
 Total &  60631 &  40461 &  39764 &  37421 &  112 & 22 \\
 \hline
\end{tabular}
\end{center}
\vspace{-15pt}
\Caption{{\label{table:filters}Number of warnings after applying a set of
sound and heuristic error filters. Column ``Before Filtering''
shows the number of warnings by the reflection-aware 1-CFA algorithm.
Other algorithms show similar patterns, which are omitted for brevity.
Column ``$F_{i,...,j}$'' represents the number of remaining warnings after applying
the $i$th to $j$th filters as defined in Section~\ref{sec:heuristic}.
The numbers in the last column are the same as the subcolumn ``\#Warning"
under column ``1-CFA'' in Table~\ref{table:results}.
} }
\end{table}


\subsection{Discussions}

\noindent \textbf{\textit{Performance and scalability.}} Our tool
has been evaluated on \subnum subjects with over \totaloc LOC and frameworks
with over 1.4 MLOC, showing good scalability. Our evaluations
were conducted on a 2.67GHz Intel Core PC with 4GB
physical memory (1GB is allocated for JVM), running Fedora 16.
For the most time-consuming subject, MyTracks, our tool finished the whole analysis
within 209 seconds using the most expensive call graph construction
algorithm: the reflection-aware 1-CFA algorithm. Analyzing
other subjects using different algorithms took less time.
The performance has not been tuned, and we believe
that it could be improved further.



\vspace{1mm}

\noindent \textbf{\textit{Threats to validity.}}
There are two major threats to validity in our evaluation. 
One threat is the degree to which the subject programs
used in our experiment are representative of true practice.
In our evaluation, the studied subjects were selected with a bias towards popularity from
well-known open-source repositories. Another threat is that we only employed three
widely-used call graph construction algorithms (i.e., RTA, 0-CFA, and 1-CFA) 
in our evaluation. It is still unknown whether using other 
call graph construction algorithms such as XTA~\cite{xta}, VTA~\cite{Sundaresan:2000} or
an incremental algorithm~\cite{inccg} may achieve better results.


\vspace{1mm}

\noindent \textbf{\textit{Limitations.}}
Our technique is limited in three aspects. First, it only considers
non-UI threads that are spawned by the UI-thread after the GUI
is initialized, and ignores other possible non-UI threads (quite unusual)
that are created during the pre-initialization GUI work. One way
to remedy this limitation is to design an analysis to identify
those non-UI threads created before a GUI is launched.
Second, like many bug-finding techniques, our technique
is neither sound nor complete. It may miss true positives due
to the graph search strategy the algorithm employs, or
issue false positives because the conservative nature of
a static analysis. Designing better call graph construction
and search algorithm may alleviate this limitation.
Third, our tool cannot compute call relationships
for inter-process communication between components. It also
requires users to manually add annotations to characterize
call relationships that involve native methods. This limitation
may lead to false negatives. Investigating the false negative
rate is ongoing work.


\vspace{1mm}

\noindent \textbf{\textit{Experimental Conclusions.}}
Invalid thread access errors  can be subtle to detect in many cases.
The technique presented in this paper offers a promising solution.
Our technique finds real-world errors and issues
few false positive warnings. Our
proposed filters are useful to reduce the number of warnings.

