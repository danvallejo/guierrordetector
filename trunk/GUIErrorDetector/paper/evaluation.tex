
\tinystep
\section{Empirical Evaluation}
\label{sec:evaluation}

Our experimental objective is three-fold: to demonstrate the effectiveness
of our approach in detecting real errors in multithreaded GUI applications, to 
compare our call graph construction algorithm
with existing ones, and to evaluate the usefulness of the proposed 
error filters.  

First, we describe our subject programs (Section~\ref{sec:subjects}) and the experimental procedure (Section~\ref{sec:procedural}).
We then show that our technique detects bugs in real-world GUI applications (Section~\ref{sec:errors}).
We also compare our technique with
a straightforward approach (Section~\ref{sec:straightforward}),  compare
different call graph construction algorithms (Section~\ref{sec:reflectionaware}), and
evaluate various graph search strategies in error detection (Section~\ref{sec:search}).
 Finally, we show that the proposed filters are effective
in removing warnings (Section~\ref{sec:filters}). 



\subsection{Subject Programs}
\label{sec:subjects}

We used \subnum open-source projects from SourceForge, Google Code,
and the Eclipse plugin marketplace as evaluation subjects. 

Five subjects (EclipseRunner, HudsonEclipse, SGTPuzzler, Fennec, and MyTracks)
are selected because they have known invalid thread access errors (1 error per subject) and
all errors have been fixed in later revisions.
We used the buggy versions to check whether our tool
can correctly identify those known errors. 
For the other four subjects, we selected them
by first searching for the
framework keywords (e.g., ``Java Swing'' or ``Java SWT'')
in the above source repositories, and then choosing subjects based on the following
criteria. First, the subject must be a Java application, not
an open library. Second, the subject must use multithreading in its implementation.
Third, the subject is listed in the first 5 result pages.
This permits us to exclude immature subjects that may contain obvious errors.
For each selected subject, we ran our tool on the latest stable release to find new errors.
%of each project to check whether
%it can find any new errors.

The subjects used in our experiment (Table~\ref{table:subjects})
include end-user applications, programming tools, and games. 

\vspace{-5pt}

% \begin{myindentpar}{-2mm}
\begin{itemize}%\addtolength{\itemsep}{-0.5\baselineskip}
\item \textbf{SWT desktop applications.}
%VirgoFTP~\cite{virgo} and FileBunker~\cite{filebunker} are two useful SWT desktop applications.
%VirgoFTP~\cite{virgo} implements a simple FTP client based on Java and the SWT UI library.
FileBunker~\cite{filebunker} is a file backup application that uses one or more GMail
accounts as its backup repository. ArecaBackup~\cite{areca} offers a local
file backup solution for Linux and Windows.

% \vspace{0.5mm}
% \vspace{0.5mm}

\item \textbf{Eclipse plugins.}
HudsonEclipse~\cite{hudson} monitors Hudson build status from Eclipse.
EclipseRunner~\cite{eclipserunner} extends Eclipse's capability of running launch configurations.

% \vspace{0.5mm}

\item \textbf{Swing applications.} %S3dropbox~\cite{s3dropbox} and SudokuSolver~\cite{sudokusolver} are two Swing desktop applications.
S3dropbox~\cite{s3dropbox}  allows users
to drag and drop files to their Amazon S3 accounts. SudokuSolver~\cite{sudokusolver}
computes Sudoku solutions using multithreaded execution. 

% \vspace{0.5mm}

\item  \textbf{Android applications.} %MyTracks~\cite{mytracks}, Fennec~\cite{fennec}, and SGTPuzzles~\cite{sgtpuzzles} are three Android applications.
SGTPuzzler~\cite{sgtpuzzles} is a single-player logic game.
Fennec~\cite{fennec}, developed by Mozilla, is the Mozilla
Firefox web browser for mobile devices. 
MyTracks~\cite{mytracks}, developed by Google, records users' GPS tracks, and provides
interfaces to visualize them on Google Maps. 

\end{itemize}
% \end{myindentpar}


\begin{table}[t]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\hspace*{-0.2cm}
\setlength{\tabcolsep}{.6\tabcolsep}
\begin{tabular}{|p{4.4cm}||c|c|c|c|}
\hline
 Program (version) & LOC & Classes & Methods \\
\hline \hline
\multicolumn{4}{|l|}{SWT desktop applications}   \\
 %\hline
 %VirgoFTP (1.3.5) &  10815 &  116 &  1955\\
 \hline
 FileBunker (1.1.2)&  14237 &  150 &  1106  \\
 \hline
 ArecaBackup (7.2)&   23226 &  444 &  4729 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Eclipse plugins}   \\
 \hline
 EclipseRunner (1.0.0) &  3101 &  48 &  354\\
 \hline
 HudsonEclipse(1.0.9)&  11077 &  74 &  649 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox (1.7) &  2353 &  42  &  224 \\
 \hline
 SudokuSolver (1.06)&  3555 &  10 &  62 \\
 \hline
 \hline
\multicolumn{4}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler (v9306.11)&  2220 &  16 &  148 \\
 \hline
 Fennec (d7fa4814218d)&  8577 &  51 &  620 \\
 \hline
 MyTracks (01d5c1e1cd47)&  20297 &  143 &  1374 \\
\hline
\hline
 Total &  \totaloc &  978 &  9266 \\
\hline
\multicolumn{4}{l}{}   \\
\hline
 GUI framework (version) & LOC & Classes & Methods  \\
\hline \hline
 SWT (3.6)&  129942 &  999 &  9643 \\
\hline
 Eclipse plugin development (3.6.2)&  460830 &  6630 &  37183 \\
\hline
Swing (1.6)&  167961 &  878 &  13159 \\
\hline
 Android (3.2)&  683289 &  5085 &  10584 \\
\hline
\hline
 Total &  1442022 &  13592 &  70569\\
\hline
\end{tabular}

\end{center}
\vspace{-15pt}
\Caption{{\label{table:subjects} Open-source programs
used in our evaluation. Column ``LOC'' is the number of lines
of code, as counted by LOCC~\cite{locc}.  Each program is analyzed
together with its GUI framework, as listed in
the bottom table.}} 
\end{table}

\smallstep
\tinystep

%\vspace{2mm}
\vspace{-3mm}
\subsection{Experimental Procedure}
\label{sec:procedural}

We ran our tool on each subject program with three call graph construction
algorithms: RTA~\cite{rta}, 0-CFA, and 1-CFA~\cite{kcfa}.  When running
each call graph construction algorithm on three Android applications, we
used two configurations: with and without our enhancements
(Section~\ref{sec:cgcon}).  We did not use more expensive algorithms like $k$-CFA ($k >$ 1),
because they do not scale to our subject programs.

Subject SGTPuzzler uses native methods to interact with
the underlying operating system. For it, we manually checked the possible
Java methods that a native method may call, and then added \annotationnum \CodeIn{@CalledByNativeMethods}
annotations for it. 
Two subjects (MyTracks and Fennec)
use a customized pattern to interact with the GUI framework.
For them, we added \filternum user-defined filters, described in Section~\ref{sec:heuristic}.
In this experiment, none of the paper
authors was familiar with the subject programs, but we found it was quite easy
to add extra annotations and user-defined filters. All these
manual parts took less than a total of 60 minutes.

We manually determined the validity of each warning.
For a known error, we compared the generated report (i.e., an
error-revealing method call chain as shown in Figure~\ref{fig:report}) against the
actual bug fix to check whether the tool identified the
buggy method. For a previously-unknown error, we submitted a new bug
report to its developers, and wrote a test driver to reproduce it.
%wrote a test driver to 


\begin{table*}[ht]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\hspace*{-0.2cm}
\setlength{\tabcolsep}{.14\tabcolsep}
\begin{tabular}{|l||c|c|c||c|c|c||c|c|c||c|}
\hline
 Subject&  \multicolumn{9}{|c||}{Our Technique} & Requiring Wrappers  \\
\cline{2-10}
 Program  &  \multicolumn{3}{|c||}{RTA }& \multicolumn{3}{|c||}{0-CFA } & \multicolumn{3}{|c||}{1-CFA } & (Section~\ref{sec:straightforward})  \\
\cline{2-11}
 & CG Size & \#Warning & \#Bug & CG Size & \#Warning & \#Bug & CG Size & \#Warning & \#Bug & \#Warning \\
\hline \hline
\multicolumn{11}{|l|}{SWT desktop applications}   \\
 %\hline
 %VirgoFTP&  12401 &  1 &  1 & 10858 & 1 & 1 & 43598 & 2 & 2& 149  \\
 \hline
 FileBunker &  18951 &  1 &  0 & 15743 & 0 & 0 & 76088 & 2 & 1& 693  \\
 \hline
 ArecaBackup&  20882 &  1  &  0 & 19697 & 1 & 1  & 116398 & 1 & 1 & 3021\\
 \hline
 \hline
\multicolumn{11}{|l|}{Eclipse plugins}   \\
 \hline
 EclipseRunner&  11248&  6 &  1 & 7201 & 6 & 1 & 26911 & 6 & 1& 202  \\
 %\hline
 %FileSync&  12132 &  xx &  xxx &8235 & xx & xx& 32565 & 1 & 1 & 331 & 1 \\
 \hline
 HudsonEclipse& 18473 &  2 &  1 & 15814 & 2 & 1& 56645 & 3 & 1 & 182 \\
 \hline
 \hline
\multicolumn{11}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox & 37751 &  0 &  0 & 30609 & 0 & 0 & 115324 & 1 & 1 & 210  \\
 \hline
  SudokuSolver&  27730&  3 &  2 & 20907 & 3 & 2 & 39299 & 2 & 2 & 356  \\
 \hline
 \hline
\multicolumn{11}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler & 13631 / 13865&  1 / 16 &  0 / 0 & 9546 / 9682& 0 / 4& 0 / 1 & 35198 / 35756 & 0 / 1  & 0 / 1& 104 \\
 \hline
 Fennec & 14058 / 14387 &  1 / 1 &  0 / 0 & 8263 / 8898 & 1 / 1 & 0 / 0& 29125/ 31759 & 3 / 3 & 1 / 1& 433 \\
 \hline
 MyTracks & 24036 / 24036 &  161 / 220 & 0 / 0 & 10803 / 13645 & 119 / 119 & 0 / 0 & 39235 / 110977 & 1 / 1 & 0 / 1 & 1192 \\
\hline
\hline
 Total & 186760 / 187323&  176 / 250 & 4 / 4 & 138583 / 142196& 132 / 136& 5 / 6 & 534223 / 609158& 19 / 20 & 8 / 10 & 6393\\
\hline
\end{tabular}
\end{center}
\vspace{-15pt}
\Caption{{\label{table:results}Experimental results in finding invalid-thread-access errors
in multithreaded GUI programs. Column ``CG Size'' is the number of nodes in the
call graph. Column ``\#Warning''
is the number of warnings issued by our tool. Column ``\#Bug'' shows
the actual bugs found. Column groups ``RTA'', ``0-CFA'',
and ``1-CFA'' show the results of using different
call graph construction algorithms.
For the Android applications, a slash ``/'' separates the result of
using standard call graph construction algorithm and our call
graph construction algorithm in Section~\ref{sec:cgcon} (dealing
with reflection calls and adding \annotationnum native method annotations
for SGTPuzzler). The \newbugs errors found in FileBunker, ArecaBackup,
S3dropbox, and SudokuSolver are previously  unknown. As a comparison, the
results of the ``Requiring Wrappers'' approach (Section~\ref{sec:straightforward}),
are shown at the far right.} }
\end{table*}

\tinystep
%\vspace{1mm}
\subsection{Results}
\label{sec:results}

%Table~\ref{table:results} show the errors in
%our subject programs, and Table~\ref{table:filters} show
%the effect of applying each heuristic filter.
\smallstep

\vspace{-1mm}
\subsubsection{Errors in Multithreaded GUI Applications}
\label{sec:errors}

As shown in Table~\ref{table:results}, our tool found
errors in each subject program. Using the 1-CFA
call graph algorithm, our tool issued \warnings warnings, among
which \bugs warnings reveal \bugs distinct errors (\newbugs were previously unknown,
and the \oldbugs known errors were correctly identified),
2 warnings are false positives, and the remaining 8 warnings
are redundant. Section~\ref{sec:reflectionaware} compares with other call graph
construction algorithms.

We submitted all \newbugs new errors to the respective developers. As of May 2012, 
1 error in S3dropbox has been confirmed, and we have reproduced all the other errors.
All found bugs and our experimental results are
publicly available at \url{http://www.cs.washington.edu/homes/szhang/guierror/}.
%in which 2 errors in FileBunker and ArecaBackup
%have not yet been verified by the developers. 
%2 errors in SudokuSolver can be reproduced by simply
%clicking its UIs, and the rest 4 errors can be reproduced
%by writing a test driver have not yet been verified
%by the developers.




\begin{figure}[t]
\hspace{4mm}{In class: com.tomczarniecki.s3.gui.DeleteBucketAction}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
59.private void deleteBucket() \ttlcb
60.    executor.execute(new Runnable() \ttlcb
61.        public void run() \ttlcb
62.            try \ttlcb
63.                controller.deleteCurrentBucket();
64.            {\ttrcb} catch (Exception e) \ttlcb
65.                logger.info("Delete failed", e);
66.                deleteError(); 
67.            \ttrcb
68.       \ttrcb
69.    \ttrcb);
70.\ttrcb

77.private void deleteError() \ttlcb
78.    String text = "Cannot delete folder .....";
79.    display.showErrorMessage("Delete failed", 
        String.format(text, controller.getSelectedBucketName())); 
80.\ttrcb
\end{alltt}
\end{CodeOut}
\vspace*{-15pt}
\Caption{{\label{fig:swingerror} An
invalid thread access error reported by our tool
in the S3dropbox Swing application. The error occurs when
the method \CodeIn{deleteCurrentBucket} invoked on line 63 throws
an exception, which causes method \CodeIn{deleteError} to
access a Swing GUI object \CodeIn{display} on line 79 from
a non-UI thread. This error was previously unknown, and has been confirmed by the S3dropbox developers.
}} %\vspace{-1mm}
\end{figure}

%Figures~\ref{fig:swingerror} amd~\ref{fig:pluginerror} show
%two real errors our tool has found. 
Figure~\ref{fig:swingerror}
shows an invalid thread access error our tool found in S3dropbox.
This error happens when the \CodeIn{deleteCurrentBucket}
call on line 63 throws an exception, making it hard to
detect by testing. We reported this error to the S3dropbox developers. Tom Czarniecki,
a key developer of S3dropbox, confirmed this single-GUI-thread
violation. He mentioned that the S3dropbox project uses
certain design patterns to avoid such violations (e.g.,
actions for UI interaction are encapsulated into a \CodeIn{Worker} interface),
but the developers still overlooked  the error our tool found.
Another reason they overlooked this violation is because some GUI frameworks like Swing
do not provide any runtime checks for invalid thread accesses. The Swing
GUI does not exhibit user-visible faults on some erroneous executions.
However, as clearly stated in the official documentation~\cite{swing}, %Swing is a single-GUI-threaded GUI toolkit and
accessing Swing GUI objects from non-UI threads risks thread interference
or memory-consistency errors.



\begin{figure}[t]
\hspace{4mm}{In class: com.eclipserunner.views.impl.RunnerView}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt} 
179.private void initializeResourceChangeListener() \ttlcb
180.  ResourcesPlugin.getWorkspace().addResourceChangeListener(
        new IResourceChangeListener() \ttlcb
181.      public void resourceChanged(IResourceChangeEvent event) \ttlcb
182.        refresh();
183.      \ttrcb
184.  \ttrcb, IResourceChangeEvent.POST\_CHANGE);
185.\ttrcb

414.public void refresh() \ttlcb
415.  getViewer().refresh();
416.\ttrcb
\end{alltt}
\end{CodeOut}
\vspace*{-15pt}
\Caption{{\label{fig:pluginerror} An
invalid thread access error reported by our tool
for the EclipseRunner plugin. In Eclipse, the
callback method \CodeIn{resourceChanged} on line 181
is invoked by non-UI threads when a \CodeIn{ResourceChangeEvent}
happens. However, the \CodeIn{refresh} method directly accesses
GUI objects (to refresh the view on line 415) without any
protection and thus triggers the error.
This error was reported by other users 13 months after the
buggy code was checked in, and fixed by developers.
}} %\vspace{-5mm}
\end{figure}

Figure~\ref{fig:pluginerror} shows an error found in the EclipseRunner
plugin. This error is event-related. It happens when a 
\CodeIn{ResourceChangeEvent} happens, which then invokes the \CodeIn{refresh}
method on line 415 to update the user interface. In EclipseRunner,
the \CodeIn{refresh} method is
called by 6 different methods from the same non-UI thread. Thus, our
tool issues 6 separate warnings to indicate
6 different ways to trigger this error. 5 of the warnings are redundant.

Besides the above two examples, other errors our tool reported are also
subtle to find. For example, our tool found two new errors in SudokuSolver.
One error only happens when
the given Sudoku is unsolvable.  The other one happens
when the program fails to launch the mail-composing window of the
user's default mail client (i.e., the \CodeIn{java.awt.Desktop.mail()}
method throws an exception after a user clicks the ``eMail Me'' button).

\enlargethispage{5pt}

We found that GUI developers have already
used design patterns, runtime checks, and testing to avoid violating
the single-GUI-thread rule. However, due to the huge space of
possible UI interactions, hard-to-find
invalid thread access errors still exist.
%Thus, a static analysis as presented in this paper
%would be useful.

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our technique can find real errors
in multithreaded GUI applications with
acceptable accuracy.


%\vspace{-4mm}
\subsubsection{Comparison to Requiring Wrappers}
\label{sec:straightforward}

As mentioned in Section~\ref{sec:finding}, one way to prevent
invalid thread access errors is to wrap every GUI-accessing operation
with message passing (i.e., via the safe UI methods).  A wrapper is not
always necessary, and indiscriminate wrapping
can give rise to other types of errors.  Nonetheless, a
straightforward and sound way to detect potential invalid thread access errors
is to issue a warning whenever a GUI-accessing operation
is not wrapped. 

This approach identifies every
error that our technique found.
However, requiring wrappers 
issues a huge number of warnings,
most of which are probably false positives (see the far right column of
Table~\ref{table:results}).
The primary reason is that this simple approach
does not globally reason about the calling relationship between
threads, UI-accessing methods, and safe UI methods, and thus it often incorrectly
classifies GUI accessing operations which will never be executed
in a non-UI thread as erroneous. Furthermore, our technique
outputs a method call chain with each reported error, which can help
developers understand how an invalid thread access error is triggered.



\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our technique provides
richer contextual information for the reported error, and 
is significantly more precise than requiring each GUI
access to be wrapped.

\subsubsection{Comparing Call Graph Construction Algorithms}
\label{sec:reflectionaware}

We next compare the 3 call graph construction algorithms (RTA, 0-CFA, and 1-CFA)
used in our experiments. As shown in Table~\ref{table:results},  1-CFA found
more errors than the other two algorithms. This
is because RTA and 0-CFA do not consider the calling context when
constructing a call graph:  they
mix calls to the same method from different callers into a single node, thus
introducing imprecision. Although the error paths exist in
the less precise graphs, our algorithm does not report them because of its heuristics
for outputting the shortest possible call chain. Figure~\ref{fig:ex} illustrates this point.

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.44]{cgexample}
  \vspace*{-5.0ex}\caption {{\label{fig:ex} (a) shows example code, in which
\CodeIn{safe()} is a Safe UI method and \CodeIn{uiAcc()} is a UI-accessing method.
(b) shows a less precise call graph built by RTA or 0-CFA, and (c) shows a more
precise call graph built by 1-CFA\@. Nodes for constructors are omitted for brevity.
\newline
Using the less precise call graph, our error
detection algorithm (Figure~\ref{fig:detectalgorithm}) reports an invalid method
call chain: \CodeIn{entry()}
$\rightarrow$ \CodeIn{f()} $\rightarrow$ \CodeIn{start()} $\rightarrow$ \CodeIn{run()}
$\rightarrow$ \CodeIn{uiAcc()}. It does not report
the actual error path because it is longer: \CodeIn{entry()} $\rightarrow$ \CodeIn{g1()} $\rightarrow$
\CodeIn{g2()} $\rightarrow$ \CodeIn{start()} $\rightarrow$ \CodeIn{run()} $\rightarrow$ \CodeIn{uiAcc()}.
The algorithm outputs the actual error path when using the more precise call graph.
}}
\end{figure}



The results in Table~\ref{table:results} also show that using the
call graph construction algorithm in Section~\ref{sec:cgcon}
helps in finding errors in Android applications. One error from the MyTracks Android application
can only be found by using the reflection-aware call graph construction algorithm (Section~\ref{sec:cg}).
This is because the error-related GUI object (\CodeIn{msgTextView}) in MyTracks is created
reflectively as follows.

{\vspace{2mm}
\hspace{3mm}{In class: com.google.android.apps.mytracks.StatsUtilities}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
97.  public void setLatLong(int id, double d) \ttlcb
98.    TextView msgTextView = (TextView) activity.\textbf{findViewById}(id);
99.    msgTextView.setText(LAT\_LONG\_FORMAT.format(d));
100. \ttrcb
\end{alltt}
\end{CodeOut}}

Another error in SGTPuzzler is only reported when adding native method
annotations (Section~\ref{sec:annotation}). 

%The error in Fennec
%can be found by using a standard call graph construction algorithm.
%This is because the error-related GUI objects are created explicitly,
%so the standard call graph construction algorithm is sufficient.

%Without
%replacing the reflection calls with explicit object creation instructions,
%a call graph construction algorithm will
%conclude that no GUI object has been created, and thus miss many UI-related
%edges in the resulting graph.

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Using the 1-CFA 
algorithm finds more errors than 0-CFA and RTA, and our reflection-aware
call graph construction algorithm helps to find errors in some
Android applications.


\subsubsection{Comparing Graph Search Strategies}
\label{sec:search}

The error detection algorithm in Figure~\ref{fig:detectalgorithm} uses a
separate BFS for each entry node.  This section evaluates three variants:
a multi-source BFS; a separate DFS for each entry node; and exhaustive
search.

The first variant uses a single BFS, but starting at multiple sources.  It deletes
lines 6 and 24 in Figure~\ref{fig:detectalgorithm} and changes line
7 to:

\vspace{0.2mm}
$\mathit{worklist}$ $\leftarrow$ $\bigcup_{\mathit{entry} \in \mathit{entryNodes}}$ getReachableStarts($\mathit{entry}$)
\vspace{0.2mm}

\noindent This variant returns the shortest path from any \CodeIn{Thread.start()} node
to any UI-accessing node, rather than the shortest path from each
\CodeIn{Thread.start()} node to any UI-accessing node as the algorithm in
Figure~\ref{fig:detectalgorithm} does.
This variant reported 8 errors and 12 false positives.   It missed 1 error in S3dropbox and 1 error in
SudokuSolver.
It visits every node in the call graph only once, rather than potentially
once per entry node, but doing so prunes out real error paths.

The second variant uses one DFS per entry node, by changing
the $\mathit{worklist}$ on line 7 of Figure~\ref{fig:detectalgorithm} to
a stack, and changing queue operations dequeue and enqueueAll
on lines 10 and 21
to pop and pushAll.
This variant reported 9 errors and 10 false positives.  It missed 1 error in FileBunker.
DFS tends to search deeper into the graph and return longer paths that are
more likely to be infeasible or to be removed by the filters.
%For the FileBunker subject, paths
%returned by DFS are much longer than BFS, and do not actually exist.

The third variant uses exhaustive search to find potential errors. This variant
enumerates all non-cyclic paths from all reachable \CodeIn{Thread.start()} nodes
to each UI-accessing node, and then checks whether each
path spawns a new thread and accesses GUI objects without using safe UI methods.
We ran this variant on each subject program for 1 hour.  It explored 5.1$\times$$10^9$ paths
on average, but did not output any of the 10 errors before it terminated.
The number of non-cyclic paths in a graph is exponential in the graph size,
and it is infeasible to enumerate all paths for a realistic call graph.
In our experiments, the smallest call graph contains 7201 nodes and the average out-degree
of each node is 2.15.  The number of distinct
non-cyclic paths is astronomically large; a rough estimate is
$2.15^{7201}$ $\approx$ 1.07$\times$$10^{2107}$.

%for a realistic call graph consisting of thousands
%of nodes, 

%only a very few amount of paths can be enumerated within a practical amount of time.

Given a sound call graph, suppose that there exists some
error-revealing path between an entry node E and a UI-accessing node U\@.  A sound
search strategy is one that reports some error-revealing path between
E and U, while an unsound strategy might report a non-error-revealing
path between the nodes (Figure~\ref{fig:ex} shows an example).
Exhaustive search is sound because it does not
miss any possible (non-cyclic) paths.  However, it is impractical.
BFS and DFS are unsound because they visit
every node, but do not traverse every path to visit that node.
Using BFS or DFS can be viewed as a heuristic filtering
step, akin to the filters of Section~\ref{sec:heuristic}.
% The heuristics of Section~\ref{sec:heuristic} are
%more effective at retaining real errors than the search variants.
%Given a sound call graph, exhaustive search is sound because it does not
%miss any possible errors.  However, it is impractical.  Compared to
%exhaustive search, using BFS or DFS can be viewed as a heuristic filtering
%step, akin to the filters of Section~\ref{sec:heuristic}.
%The heuristics of Section~\ref{sec:heuristic} are
%more effective at retaining real errors than the search variants.

%   The algorithm of
% Figure~\ref{fig:detectalgorithm}, which does multiple BFS traversals, does
% less pruning, and runs more slowly, than the variant that does one
% multi-source BFS, but

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our algorithm finds more errors than
using multi-source BFS, DFS, or exhaustive search.



\begin{table}[t]
\begin{center}
 \fontsize{9pt}{\baselineskip}\selectfont
\setlength{\tabcolsep}{.34\tabcolsep}
\hspace*{-0.2cm}
\begin{tabular}{|l||c|c|c|c|c|c|}
\hline
 & \multicolumn{6}{|c|}{Number of Warnings}  \\
\cline{2-7}
 Subject & Before & \multicolumn{2}{|c|}{Sound Filters}  &  \multicolumn{3}{|c|}{Heuristic Filters}  \\
\cline{3-7}
 Program &Filtering  & $F_1$ & $F_{1,2}$ & $F_{1,2,3}$&$F_{1,2,3,4}$ & $F_{1,2,3,4,5}$\\
\hline \hline
\multicolumn{7}{|l|}{SWT desktop applications}   \\
 %\hline
 %VirgoFTP &  21 &  21 &  21 & 7 &  2 & 2\\
 \hline
 FileBunker &  4494 &  4494 &  4494 &  3210 &  10  & 2\\
 \hline
 ArecaBackup &  6219 &  438 & 438 &  438  &  1 & 1\\
 \hline
 \hline
\multicolumn{7}{|l|}{Eclipse plugins}   \\
 %\hline
 %EclipseRunner &  xxxx &  xx &  xxx & xx &  xxx & xx\\
 \hline
 EclipseRunner&  1644 &  1644 &  1644 & 1644 &  6 & 6\\
 \hline
 HundsonEclipse&  1367 &  567 &  567 & 567 &  3 & 3\\
 \hline
 \hline
\multicolumn{7}{|l|}{Swing desktop applications}   \\
 \hline
 S3dropbox&  45528 &  31978 &  31978 & 30975 &  9 & 1\\
 \hline
 SudokuSolver &  58 &  58 &  58 & 58  &  2 & 2\\
 \hline
 \hline
\multicolumn{7}{|l|}{Android mobile applications}   \\
 \hline
 SGTPuzzler&  2 &  1 &  1 & 1 &  1 & 1\\
 \hline
 Fennec &  122 &  84 & 80 & 80 &  9 & 3\\
 \hline
 MyTracks &  1176 &  1176 &  483 & 441 &  69 & 1 \\
\hline
 \hline
 Total &  60610 &  40440 &  39753 &  37414 &  110 & \warnings \\
 \hline
\end{tabular}
\end{center}
\vspace{-15pt}
\Caption{{\label{table:filters}Number of warnings after applying a set of
sound and heuristic error filters. Column ``Before Filtering''
shows the number of warnings by the reflection-aware 1-CFA algorithm.
Other algorithms show similar patterns, which are omitted for brevity.
Column ``$F_{i,...,j}$'' represents the number of remaining warnings after applying
the $i$th to $j$th filters as defined in Section~\ref{sec:heuristic}.
The numbers in the last column are the same as the subcolumn ``\#Warning"
under column ``1-CFA'' in Table~\ref{table:results}.
} } \vspace{-2mm}
\end{table}


\subsubsection{Evaluating Error Filters}
\label{sec:filters}

Table~\ref{table:filters} measures the effectiveness of the
error filters of Section~\ref{sec:heuristic}.
The five error filters removed 99.96\% of the reported warnings as likely false positives
or redundant warnings. Specifically, the two sound filters 1 and 2 
removed 34.44\% of the warnings, and the three heuristic filters 3, 4, and 5
removed a further 65.52\% of the warnings. The most effective filter is
\#4, for removing reports with the same head methods from the entry node to \CodeIn{Thread.start()}.

\vspace{1mm}

\noindent \textbf{\textit{Summary.}} Our proposed error filters are 
effective in reducing the number of warnings.
%Although a static analysis may
%issue false positives or redundant reports, a set of well-designed
%error filters can remove most of them.
%Heuristic filter, effective.


\subsection{Discussion}

\label{sec:performance}

\noindent \textbf{\textit{Performance and scalability.}} Our tool
has been evaluated on \subnum subject programs with \totaloc LOC and frameworks
with 1.4 MLOC, showing good scalability. Our evaluations
were conducted on a 2.67GHz Intel Core PC with 4GB
physical memory (1GB is allocated for the JVM), running Windows 7.
For the most time-consuming subject, S3dropbox, our tool finished the whole analysis
within 252 seconds using the most expensive 1-CFA call graph construction
algorithm. Analyzing other subjects or using different algorithms took less time.
Call graph construction took 33--91\% of the total time.


\vspace{1mm}

\noindent \textbf{\textit{Threats to validity.}}
There are two major threats to validity in our evaluation. 
One threat is the degree to which the subject programs
used in our experiment are representative of true practice.
In our evaluation, we only selected subjects from
open-source repositories. Another threat is that we only employed three
widely-used call graph construction algorithms (i.e., RTA, 0-CFA, and 1-CFA) 
in our evaluation. Using other 
call graph construction algorithms %such as XTA~\cite{xta} or VTA~\cite{Sundaresan:2000} 
 might achieve different results.


\vspace{1mm}

\noindent \textbf{\textit{Limitations.}}
Our technique is limited in three aspects. First, it only considers
non-UI threads that are spawned by the UI-thread after the GUI
is initialized, and ignores other possible non-UI threads (quite unusual)
that are created during the pre-initialization GUI work. One way
to remedy this limitation is to design an analysis to identify
those non-UI threads created before a GUI is launched.
Second, like many bug-finding techniques, our technique
is neither sound nor complete. It may issue false positives
due to the conservative nature of a static analysis.
It may miss true positives due to the graph search strategy,
and it never reports cyclic paths. Furthermore, for the
sake of scalability, our tool implementation uses the default
configuration of WALA and ignores part of the AWT library. Thus,
it missed one error in S3dropbox which we later found by using pluggable type-checking~\cite{DietlDEMS2011}.
Designing better call graph construction algorithms,
graph search strategies, and filtering heuristics may alleviate this limitation.
Third, our tool cannot compute call relationships
for inter-process communication between components. It also
requires users to manually add annotations to characterize
call relationships that involve native methods. This limitation
may lead to false negatives. Investigating the false negative
rate is ongoing work.


\vspace{1mm}

\noindent \textbf{\textit{Experimental Conclusions.}}
Invalid thread access errors  can be subtle to detect in many cases.
The technique presented in this paper offers a promising solution.
Our technique finds real-world errors and issues
few false positive warnings. Our
proposed filters are useful in reducing the number of warnings.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "guierror"
%%% TeX-command-default: "PDF"
%%% End: 

%  LocalWords:  multithreaded SWT multithreading 2mm VirgoFTP UI GMail S3
%  LocalWords:  FileBunker ArecaBackup plugins HudsonEclipse EclipseRunner
%  LocalWords:  S3dropbox SudokuSolver Sudoku mutlithreaded SGTPuzzler 9pt
%  LocalWords:  Fennec MyTracks LOC v9306 plugin LOCC RTA CFA 9pt eMail g1
%  LocalWords:  CalledByNativeMethods deleteBucket deleteCurrentBucket g2
%  LocalWords:  deleteError showErrorMessage getSelectedBucketName uiAcc
%  LocalWords:  Czarniecki initializeResourceChangeListener getWorkspace
%  LocalWords:  ResourcesPlugin addResourceChangeListener resourceChanged
%  LocalWords:  IResourceChangeListener IResourceChangeEvent getViewer BFS
%  LocalWords:  ResourceChangeEvent msgTextView setLatLong TextView DFS
%  LocalWords:  findViewById setText getReachableStarts enqueueAll pushAll
%  LocalWords:  HundsonEclipse subcolumn MLOC 67GHz 4GB 1GB XTA VTA pre
