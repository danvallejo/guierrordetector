\section{Related Work}

Work related to this paper falls into three main categories; (1)
techniques and tools to analyze and test GUI programs; (2)
bug finding techniques for general multithreaded programs; and (3)
call graph construction algorithms.

\tinystep
\subsection{Analysis and Testing for GUI Applications}
%\vspace{1mm}

%\noindent \textit{\textbf{Analysis and Testing for GUI Applications}}
Automated GUI testing is a challenging tasks~\cite{Bertolino:2007:STR:1253532.1254712,
Harrold:2000:TR:336512.336532}.
 Many GUI analysis and testing techniques have been proposed in the past decade.
Existing techniques automate
some aspect(s) of GUI testing including model creation
(for model-based testing)~\cite{androidtesting}, %, Xie:2006:MTC:1172962.1172990},
test generation~\cite{YuanMemonICSE2007},
test oracle creation~\cite{MemonFSE2000}, test execution~\cite{YuanCohenMemonTSE2011},
and test script repairing~\cite{Huang:2010:RGT:1828417.1828465, Daniel:2011:AGR:2002931.2002937}.
For example,
%Kervinen et al.~\cite{Kervinen06model-basedtesting} present a formal model and architecture for testing
%concurrently running applications. The behavior of the system under test
%needs to be specified manually as a labeled transition system. 
Guitar~\cite{YuanCohenMemonTSE2011, YuanMemonICSE2007}
is a GUI testing framework for Java and Microsoft Windows applications. 
Yuan and Memon~\cite{YuanMemonICSE2007} generate event-sequence based test cases for GUI
programs using a structural event generation graph. 
However, testing is often insufficient to detect many potential
errors in a GUI application due to the huge space of possible UI interactions.
%The large number of possible interactions
%requires a large number of test inputs that require substantial human effort.
In contrast, as suggested in this paper,
using a static analysis can explore paths to find potential errors without actually executing the tested code,
and find potential errors missed by testing.
Compared to software testing, a static analysis tool may
report false positives and redundant warnings due to its conservative nature.
However, as we demonstrated in our experiments, using a few simple error
filters can dramatically reduce the number of warnings to
an acceptable level.


Michail and Xie~\cite{michail05:helping} proposed a tool-based approach to help users avoid bugs
in GUI applications. Their approach monitors user's action in the background,
and gives a user a warning as well as the opportunity to abort the action, when
a user attempts an action that has led to problems in the past. 
As a comparison, our work aims to find unknown errors in multithreaded
GUI applications, while their work aims to prevent an existing bug
from happening again.
%is significantly different than their


Recently, Payet and Spoto~\cite{Payet:2011:SAA:2032266.2032299} presented a static
analysis framework for Android programs based on  abstract
interpretation. Their framework focuses on the Android platform, and
 consists of 7 existing static analyses such as
nullness analysis, class analysis, and termination analysis.  However,
their framework does not support detecting the invalid thread access
errors, and uses a quite different abstraction than ours.
To the best of our knowledge, we are the first to address the invalid
thread access error detection problem for multithreaded GUI applications, and
our core technique is a general one that can be tailored for
various GUI frameworks.


\tinystep
\subsection{Finding Bugs in Multithreaded Programs}

%\vspace{1mm}

%\noindent \textit{\textbf{Finding Bugs in Multithreaded Programs}}
A rich body of techniques have been developed to detect bugs in multithreaded programs~\cite{Huang:2011:PPC:2001420.2001438, Weeratunge:2010, Huang:2011:EST}.
%Active testing frameworks like AssertFuzzer~\cite{Sen:2008} uses the trace information to detect
%and create atomicity schedule violations.
Static analysis tools such as Chord~\cite{Naik:2006}
 explore multithreaded bugs by statically analyzing the program. Runtime
analysis tools such as Eraser~\cite{Savage:1997}  dynamically detect concurrency bugs using the lockset
algorithms or some criteria based automata. 
%Bodden and Havelund~\cite{Bodden:2008} uses AOP for
%race detection by providing three novel pointcuts to the AspectJ language.
More recently, Goldilock~\cite{Elmas:2007} uses the hybrid model that combines the happens-before and lock-based
approaches to identify data races based on an execution.
%By exploiting the insight
%that a full generality of the happens-before is unnecessary in most data accesses,
%FastTrack~\cite{Flanagan:2009} proposes an adaptive representation for the happen-before
%relation to efficiently and precisely detect races at runtime.
However, finding
invalid thread access errors is quite different than detecting data races.
A data race occurs when two concurrent threads access
a shared variable and when at least one access is a write and the threads
use no explicit mechanism to prevent the accesses from being simultaneous. In contrast,
an invalid thread access error occurs when a non-UI thread accesses (reads or writes) a GUI object.
Unlike detecting data races, finding invalid thread access error does not require monitoring every shared-memory
reference and verify that consistent locking behavior is observed among different threads.
A technique only needs to track whether a non-UI thread can accesses a GUI object or not,
and is much cheaper.
How to leverage the recent advance in data race detection to 
improve our technique is our future work.

%Significantly different from the concurrency bug finding work....

%They are often limited to detect errors manifested in a specific concrete execution.

An alternative way to find bugs in multithreaded programs is using model checking~\cite{Nori:2010:ESO, Inverardi:2000, Siegel:2008}.
By exhaustively exploring the thread scheduling space, a model checker can
report counter examples for the potential bugs with a counter example.
%For example,
%CHESS~\cite{chess} dynamically explores the thread scheduling decisions to expose
%concurrency bugs using a context-bounded approach. 
%Shacham et al~\cite{Shacham:2007} uses
%a model checker to construct the witness for data races reported by the lockset algorithm.
Unfortunately, due to the exponential size of the search space,
 it is hard for model checking approaches to scale to a realistic multithreaded GUI application
 without compromising the detection capability. To our best knowledge,
we are not aware of any software model checking approach can scale to subjects
as large as those used in our experiments (including the library code).
The technique presented in this paper is specifically designed to find invalid thread
errors instead of being a general property checking tool. 
It chooses call graph as a coarse-grained program representation with a
set of error filters, to achieve good scalability with reasonable accuracy.

%For this reason,
%our technique achieves good scalability with reasonable precision.

\tinystep

\subsection{Call Graph Construction Algorithms}
%\vspace{1mm}

%\noindent \textit{\textbf{Call Graph Construction Algorithms}}
A lot of effort has been spent on building call graphs for
Object-oriented programs~\cite{rta, kcfa, xta, inccg, Sundaresan:2000}.
We briefly mention some of the highlights of call graph construction
algorithms for Java here. Grove et al~\cite{kcfa} described a unified
framework for expressing call graph construction algorithms, and
studied different instantiations of the framework.
Tip and Palsberg~\cite{xta} quantitatively compared
several low-cost call graph construction algorithms for Java.
Sundaresan et al.~\cite{Sundaresan:2000} went beyond the
CHA and RTA~\cite{rta} approaches and used type propagation
to build a more precise call graph.
However, the use of reflection makes
those algorithms insufficient to build a complete call graph.
As reflected in our experiments, using standard call graph algorithms
misses errors in some Android applications. %, due to the incompleteness of the resulting graph.


To enable call graph construction in the presence of  reflection,
Livshits et al.~\cite{Livshits:2005} presented a static analysis
to reason about reflective calls. The analysis
attempts to infer additional information stored in string constants to resolve
reflective calls statically. Their approach focuses on standard Java
reflection calls (e.g., \CodeIn{Class.forName}) instead of the
framework-specific ones (e.g., \CodeIn{View.findViewById}).
The standard call graph algorithms implemented in WALA, which we used
in our experiments, actually handle standard Java
reflection calls as~\cite{Livshits:2005} does, but still fails to build
a sufficiently complete call graph for
Android applications. TamiFlex~\cite{Bodden:2011}, a pure dynamic
approach, records all reflectively-created class instances
by intercepting JVM system calls, and re-inserts those recorded 
class into a program. However, TamiFlex requires a set of representative
program executions and is only sound with respect to the given executions.
Perhaps the closest work to our call graph
construction algorithm is Payet and Spoto's Julia
system~\cite{Payet:2011:SAA:2032266.2032299}. The Julia system
needs to first instrument Android's library code that performs the XML inflation,
and then replaces the \CodeIn{findViewById} call with the corresponding
object creation expressions. In additiona, the Julia system does not handle
native methods when building call graphs. In contrast, our technique provides
annotation support for native methods, and our tool does not need a separate
pass of off-line instrumentation. The reflection-aware call graph is created
online by incerpting the standard call graph construction process.





%There are few algorithms have been studied to construct call
%A recent paper by Hirzel, Diwan, and Hind addresses the issues of dynamic
%class loading, native methods, and reflection in order to deal with the full complexity
%of Java in the implementation of a common pointer analysis [5]. Their
%approach involves converting the pointer analysis [6] into an online algorithm:
%they add constraints between analysis nodes as they are discovered at runtime.
%Newly generated constraints cause re-computation and the results are propagated
%to analysis clients such as a method inliner and a garbage collector at
%runtime. Their approach leverages the class hierarchy analysis (CHA) to update
%the call graph. Our technique uses a more precise pointer analysis-based
%approach to call graph construction.


 
