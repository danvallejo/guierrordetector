\section{Introduction}
\label{sec:introduction}

End-user satisfaction depends in part on the responsiveness and
robustness of a software application's GUI.

To make the GUI more responsive, 
GUI applications often spawn separate threads to handle time-consuming
operations in the background, such as expensive computation, I/O tasks,
and network requests. This permits the GUI to respond to new events
even before the lengthy task completes. However, the use of multiple threads
enables new types of errors that may compromise robustness.
We now discuss a standard programming rule for multithreaded GUIs, the consequences
of violating it, and a technique for statically detecting such violations.



%\subsection{The Single-thread Rule for GUI Object Access}
%ugly hack
\subsection{\hspace{-1.1ex}\mbox{The}~\mbox{Single-thread}~\mbox{Rule}~\mbox{for}~\mbox{GUI}~\mbox{Object}~\mbox{Access}}

Many popular GUI frameworks such as Swing~\cite{swing}, SWT~\cite{swt}, Eclipse plugin~\cite{eclipse},
Android~\cite{android}, Qt~\cite{qt}, and MacOS Cocoa~\cite{macos}
adopt the \textit{single-GUI-thread rule}:

\vspace{-2mm}

\begin{quote}
All GUI objects, including visual components and data models, must be
 accessed exclusively from the \textit{event dispatching thread}.
\end{quote}

\vspace{-2mm}

The \textit{event dispatching thread}, also called the \textit{UI thread}, is a single
special thread initialized by the GUI framework, where all event-handling code
is executed. All code that interacts with GUI objects must also
execute on that thread.  There are several advantages to the single-GUI-thread rule:

\begin{itemize}

\item Concurrency errors, such as races and deadlocks, never occur on GUI objects. 
GUI developers need not become experts at concurrent programming. Programming the
framework itself is also simpler and less error-prone.

\tinystep

\item The single-GUI-thread rule incurs less overhead.
Otherwise, whenever the framework calls a method that might
be implemented in client code (e.g., any non-final public or protected method in a public class),
the framework must save its state and release all locks so that the client code can grab locks
if necessary. When GUI objects return from the method, the framework must re-grab their locks and
restore states.  Even applications that do not require concurrent access to the GUI
must bear this cost.

\tinystep

\item GUI events are dispatched in a predictable order from a single event queue.
If the thread scheduler could arbitrarily interleave component changes, then event processing,
program comprehension, and testing would be more difficult.
\end{itemize}

%Single-threaded GUI frameworks are not unique to Java; ,
%and many others are also single-GUI-threaded.

\subsection{The Invalid Thread Access Error}

The single-GUI-thread rule requires GUI application developers to
 ensure that all GUI objects are accessed only by the UI thread.
If not, an \textit{invalid thread access error} will occur. This may
terminate the application, but it is considered preferable
to nondeterministic concurrency errors.

The single-GUI-thread rule can be easily violated, since a spawned non-UI thread often needs to update
the GUI  after its  task is finished.
In practice, invalid thread access errors are \textit{frequent}, \textit{severe}, and \textit{hard to debug}.
%and \textit{difficult to avoid}.

Take the popular Standard Widget Toolkit (SWT) GUI framework as an example. 
Invalid thread access is one of the top 3 bugs in developing a SWT application, and is
the source of many concurrency bugs~\cite{top3bugs}.
A Google search for ``SWTException:Invalid thread access''  returns over 11,800 entries,
consisting of numerous bug reports, forum posts, and mailing list threads on
this problem. Eclipse, the IDE for Java development, is built on top of SWT\@.
Searching for ``SWTException:Invalid thread access'' in Eclipse's bug repository
and discussion forum returns over 2732 bug reports and 351 distinct discussion threads, respectively. 
We manually studied all 156 distinct \textit{confirmed} bug reports, and 
found this error has been confirmed in at least 20 distinct Eclipse projects
and 40 distinct Eclipse components. Even after over 10 years of active development,
a recent release of Eclipse still contains this error (bug id: 333533, reported in January 2011).
 In addition, the invalid thread access error
is severe. It is user-perceivable, it cannot be recovered by the program itself,
and it often terminates the whole application. In many circumstances as described in the bug reports,
users must restart the application to recover from the error.
Furthermore, many reported  errors are non-trivial to diagnose and fix.
Developers usually need non-local reasoning to find the specific
UI interactions that can trigger the bug;  it took developers 2 years
to fix Eclipse bug 51757 and verify the patch.

\begin{figure}[t]
\hspace{6mm}\small{In class: org.mozilla.gecko.gfx.LayerView}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
68.  public LayerView(Context context, LayerController controller) \ttlcb
69.     super(context);
        ....
73.     mRenderer = new LayerRenderer(this);
74.     setRenderer(mRenderer);
        ...
     \ttrcb
\end{alltt}
\end{CodeOut}
\hspace{6mm} \small{In Android library class: android.opengl.GLSurfaceView}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
272. public void setRenderer(Renderer renderer) \ttlcb
        ...
282.    mGLThread = new GLThread(renderer);
283.    mGLThread.start();   
     \ttrcb
\end{alltt}
\end{CodeOut}
 \hspace{6mm}\small{In class: org.mozilla.gecko.gfx.LayerRenderer}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
220. public void onSurfaceChanged(GL10 gl, int width, int height) \ttlcb
221.    gl.glViewport(0, 0, width, height);
222.    mView.setViewportSize(new IntSize(width, height));
     \ttrcb
\end{alltt}
\end{CodeOut}
\tinystep
\vspace*{-3.0ex} \Caption{{\label{fig:androiderror} 
Bug 703256 reported on 11/17/2011 in Fennec (Mozilla Firefox for Android)
release 10.0.a.rc3. On line 74, \CodeIn{LayerView}'s constructor
calls method \CodeIn{setRenderer} which 
spawns a new thread on line 283. This newly created, non-UI thread calls back method
\CodeIn{onSurfaceChanged} that accesses GUI objects on line 222 of \CodeIn{LayerRenderer},
causing an invalid thread access error. Our tool
finds this error and generates a report as shown in
Figure~\ref{fig:report}.
}} %\vspace{-5mm}
\end{figure}

The invalid thread access error is not unique to the SWT framework. Other recent GUI frameworks
like Android suffer from similar problems. For example, 
Figure~\ref{fig:androiderror} shows a recently-reported bug in the Android version of Mozilla Firefox.
This bug is particularly difficult to diagnose, 
since the code that spawns a new thread inside the \CodeIn{setRenderer} method is
in an Android library.

%It may work during development, but like most concurrent bugs, you'll start to see weird exceptions come up that seem completely unrelated, and occur non-- usually spotted AFTER you've shipped by real users. Not good.

%Also, you've got no confidence that your app will continue to work on future CPUs with more and more cores - which are more prone to encountering weird threading issues due to them being truely concurrent rather than just simulated by the OS.


\subsection{Finding Invalid Thread Access Errors}
\label{sec:finding}

To ensure that GUIs behave correctly, developers must prevent or detect invalid thread
access errors. Current techniques are not effective. %must be developed.% to alleviate this problem.

%Software testing, the most widely used method to ensure program correctness,
%is insufficient to detect such errors. 
It is infeasible for testing to cover the enormous space of possible interactions
with a GUI. Each sequence of GUI events can result in
a different state, and each GUI event may need to be evaluated in all of
these states. A  software system like Eclipse
often has a test suite that achieves fairly high statement coverage,
but many paths executed by bug-triggering UI sequences are still not covered.

Stylized coding patterns are also inadequate. One possible rule is to always
access GUI objects via asynchronous message passing, to ensure a GUI object is accessed in
the UI thread. For example, a developer could have prevented the bug in Figure~\ref{fig:androiderror}
by wrapping line 222 inside a \CodeIn{post} message-passing method\footnote{The
\CodeIn{post} method in class \CodeIn{android.widget.View} is
a standard way to send asynchronous messages to the UI-thread.}, as follows:

{\vspace{2mm}
\hspace{3mm}\small{In class: org.mozilla.gecko.gfx.LayerRenderer}
\vspace{-2mm}
\begin{CodeOut}
\begin{alltt}
220. public void onSurfaceChanged(GL10 gl, int width, int height) \ttlcb
221.     gl.glViewport(0, 0, width, height);
         \textbf{mView.post(new Runnable() \ttlcb}
             \textbf{public void run() \ttlcb}
222.             mView.setViewportSize(new IntSize(width, height));
             \textbf{\ttrcb}
         \textbf{\ttrcb);}
     \ttrcb
\end{alltt}
\end{CodeOut}}

Such an approach is desirable for accesses from non-UI threads, but it is unnecessary.
In our evaluation on real-world programs, we found that a simple analysis that
requires GUI operations to be in a message issued
an unacceptable number of warnings. %false positives and redundant warnings.
Furthermore, this approach is dangerous for accesses from the UI thread. Asynchronized message passing offers
no timing guarantee, so a GUI object may have already been
disposed before the message sent to it arrives, causing other bugs. 


%program transformation to wrap
%every possible UI-accessing operation with asynchronized message passing
%may avoid the invalid thread error. However, such an approach is problematic,
%because using asynchronized message passing has no timing
%guarantee. It is entirely possible that, in some cases, a GUI object has already been
%disposed before the message sent to arrives, causing other bugs. Thus, programmers can not use
%it everywhere; instead, they must choose carefully to put it in appropriate places
%with extreme caution. This makes invalid thread errors even harder to avoid,
%and demands a proactive technique to detect them.

%Here are a few reasons, first, for the sake of efficiency, UI must use multi-thread to perform updates and processing user requests; second, there is no language level enforcement to prevent this error; and third, programmers often forget corner cases like an event listener that may init a non-UI thread to update a UI component.
%Furthermore, asyncExec has no timing guarantee, and programmers can not use it everywhere

\smallskip

\textbf{Our approach: static analysis.}
This paper uses static analysis to find potential GUI errors.
Static analysis has two advantages compared to dynamic approaches such as
 testing. First, a static analysis can explore paths of the program without
executing the code, and without the need for a test suite.
Second, a static analysis can verify the code: if a sound static analysis
reports no warnings, the code is guaranteed to be bug-free. 


\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
   org.mozilla.gecko.gfx.LayerView.<init>(Context;LayerController)
-> android.opengl.GLSurfaceView.setRenderer(GLSurfaceView\$Renderer;)
-> java.lang.Thread.start()
-> android.opengl.GLSurfaceView\$GLThread.run()
-> android.opengl.GLSurfaceView\$GLThread.guardedRun()
-> org.mozilla.gecko.gfx.LayerRenderer.onSurfaceChanged(GL10;II)
-> org.mozilla.gecko.gfx.LayerView.setViewportSize(IntSize;)
   ... 
-> android.view.ViewRoot.recomputeViewAttributes(View;)
-> android.view.ViewRoot.checkThread()
\end{alltt}
\end{CodeOut}
%\hspace{5mm}\CodeIn{\scriptsize{org.mozilla.gecko.gfx.LayerView.<init>(Context;LayerController)}}\\
%$\rightarrow$\CodeIn{ \scriptsize{android.opengl.GLSurfaceView.setRenderer(GLSurfaceView\$Renderer;)}}\\
%$\rightarrow$\CodeIn{ \scriptsize{java.lang.Thread.start()}}\\
%$\rightarrow$\CodeIn{ \scriptsize{android.opengl.GLSurfaceView\$GLThread.run()}}\\
%$\rightarrow$\CodeIn{ \scriptsize{android.opengl.GLSurfaceView\$GLThread.guardedRun()}}\\
%$\rightarrow$\CodeIn{ \scriptsize{org.mozilla.gecko.gfx.LayerRenderer.onSurfaceChanged(GL10;II)}}\\
%$\rightarrow$\CodeIn{ \scriptsize{org.mozilla.gecko.gfx.LayerView.setViewportSize(IntSize;)}}\\
%\hspace{5mm}\CodeIn{...}\\
%$\rightarrow$\CodeIn{ \scriptsize{android.view.ViewRoot.checkThread()}}
\tinystep
\vspace*{-3.0ex} \Caption{{\label{fig:report} Our tool reports
a method call chain that reveals the potential error in
Figure~\ref{fig:androiderror}. $\rightarrow$ represents
the call relationship
between methods, and \CodeIn{checkThread} is an Android library
method  that checks whether the current thread is the
event dispatching thread before accessing a GUI object.
8 more methods in the call chain, shown as
``\CodeIn{\small{...}}" above, are omitted for brevity.
}} %\vspace{-5mm}
\end{figure}

Our static analysis formulates finding invalid thread access as a call graph reachability
problem. Given a call graph, our technique traverses
paths from its entry nodes, checking whether
any path accesses a GUI object from a non-UI thread. If 
a suspicious path is found, the static analysis warns of a potential error.
The warning is in the form of a method
call chain from the starting point.
As an example, Figure~\ref{fig:report} shows a report produced
by our static analysis for the buggy code in Figure~\ref{fig:androiderror}.
This report clearly indicates how a new, non-UI thread is spawned and
accesses GUI objects. The generated report allows  developers to
inspect the method call chain, understand how the error
could be triggered, and fix it if it is a real bug.

Our static analysis is independent of the call graph construction algorithm.
%Given a sound call graph, our analysis is sound in that it does
%not miss true positives.
However, modern GUI applications tend to use reflection, and
in the presence of reflection, existing call graph construction algorithms such as RTA~\cite{rta}
and k-CFA~\cite{kcfa} fail to build a complete call graph.
To alleviate this problem, we present an algorithm to build a reflection-aware call graph, and
also compare its usefulness with existing call graph construction algorithms in
our experiments.

Static analysis may report false positives due to its
conservative nature, or multiple warnings that actually correspond
to the same error. To address such limitations, we devise a set
 of error filters to remove likely false positives and redundant warnings.
The filters introduce potential unsoundness to our algorithm, but in practice
they work well and make our technique usable.

\subsection{Technique Instantiation and Evaluation}


We implemented an invalid-thread-error detection tool that supports
four popular GUI frameworks: SWT, Eclipse plugin environment,
Swing, and Android. Swing and SWT are the
two dominant GUI frameworks for desktop Java applications.
Eclipse is a widely-used IDE for Java. Android is the \#1 platform for
mobile applications with market share 56\% as of September 2011.
Although our technique is applicable to any GUI
framework with the single-GUI-thread rule, each framework
has its own definition of \textit{UI thread} and \textit{program 
entry points}. Thus, our implementation is parameterized with respect to
those framework-specific parts (see Section~\ref{sec:platforms}).


Our tool works in an automatic manner,
and scales to realistic programs.
We evaluated our implementation on \subnum programs comprising \totaloc LOC.
The experimental results demonstrate
that: our technique is effective (it found \bugs real-world errors
 and produced only \falses false positive warnings);
our reflection-aware call graph construction algorithm helps in
finding errors in Android applications;
and our proposed error filters significantly reduce the number of warnings.
%false positives and redundant warnings.


\subsection{Contributions}

This paper makes the following contributions:

\tinystep

\begin{itemize}
\item \textbf{Problem.} To the best of our knowledge, we are the first to address
the invalid thread access error detection problem for multithreaded GUI applications.

\tinystep

\item \textbf{Technique.} We formulate finding
the invalid thread access error as a call graph reachability problem,
and present a general error detection technique.
In addition, we use a reflection-aware
call graph construction algorithm (Section~\ref{sec:technique}).

\tinystep

\item \textbf{Implementation.} We implemented our technique and
instantiated it for four
popular GUI platforms: SWT, Eclipse plugin, Swing, and Android (Section~\ref{sec:implementation}). Our
tool implementation is publicly available at
\url{http://guierrordetector.googlecode.com}.

\tinystep

\item \textbf{Evaluation.} We applied our tool to \subnum programs 
from 4 different frameworks, comprising \totaloc LOC. The results
show the usefulness of the proposed technique (Section~\ref{sec:evaluation}).

\end{itemize}

