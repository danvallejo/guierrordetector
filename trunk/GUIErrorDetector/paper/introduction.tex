\section{Introduction}

Graphical User Interfaces (GUIs) are one of the most important parts of
software. Most software developed in recent years has a GUI, and the only
way for the end-user to interact with the software application is through
the GUI. Hence, end-user satisfaction and retention of a software application
 are largely determined by the usability and correctness of
its GUIs.

To make the GUIs more responsive and better utilize the increasingly available
computation power in the multi-core era, GUI applications often spawn separate
threads to handle time-consuming operations in the background, such as expensive
computations, I/O tasks, and network requests. Using threads for those lengthy tasks
makes a GUI active by allowing the timing of operations not delay unrelated parts of a 
GUI application.



\subsection{The Single-thread Rule}

Nowadays, many popular GUI frameworks such as Swing~\cite{swing}, SWT~\cite{swt}, Android~\cite{android},
Qt~\cite{qt}, MacOS Cocoa~\cite{macos}, and X Windows~\cite{xwindow} 
adapt the \textit{single-thread rule}:

\vspace{-2mm}

\begin{quote}
All GUI objects, including visual components and data models, must be
 accessed exclusively from the \textit{event dispatching thread}.
\end{quote}

\vspace{-2mm}

The \textit{event dispatching thread}, or called \textit{UI thread}, is a global special
thread initialized by the GUI framework, where all event-handling code
is executed. All code that interacts with GUI objects must also
execute on this thread.  There are several advantages to adapt the single-thread rule:

\begin{itemize}

\item GUI developers do not have to have an in-depth
understanding of concurrency programming. A GUI framework in which all components
must fully support multithreaded access can be difficult to extend, particularly
for developers who are not expert at threads programming.

\item Events are dispatched in a predictable order. Mouse and keyboard events, timer events, 
paint requests, and other user-defined events are dispatched from the same event queue.
In contrast, in a GUI framework without adapting the single-thread rule where components
support multithreaded access, any component changes can be interleaved with event
processing at the whim of the thread scheduler. This makes program behavior comprehension hard,
 and comprehensive testing difficult or impossible. 

\item Single-thread rule incurs less overhead.
A GUI framework that attempts to carefully lock critical sections can spend a substantial
amount of time and space managing locks. Whenever the framework calls a method that might
be implemented in client code (for example, any public or protected method in a public class),
the framework must save its state and release all locks so that the client code can grab locks
if necessary. When GUI objects return from the method, the framework must re-grab their locks and
restore states. Therefore, all applications using the framework will bear the cost of this, even though most
applications do not require concurrent access to the GUI.

\end{itemize}

%Single-threaded GUI frameworks are not unique to Java; ,
%and many others are also single-threaded.

\subsection{The Invalid Thread Access Error}

Despite the convenience that the single-thread rule brings to build a
GUI framework, it pushes the thread safety burden back onto the GUI application developers,
who must make sure all GUI objects are accessed by the UI thread.

In a multithreaded GUI application, the single-thread rule can be
easily violated since a spawned non-UI thread often needs to update
the GUI to display results after its computation task is finished.
For example, a server program can get requests from other programs
that might be running on different machines. These requests can come at any time,
and they result in one of the server's methods being invoked in some thread.
After handling the request, the GUI-update code must be executed on the UI-thread.
If not, an \textit{invalid thread access} will error occur. In practice, such
invalid thread access error is \textit{frequent}, \textit{pervasive}, \textit{severe}.
and \textit{difficult to avoid}.

Take the popular Standard Widget Toolkit (SWT)~\cite{swt} GUI framework as an example. 
In a recent survey~\footnote{\url{http://www.slideshare.net/lakshmip/top-3-swt-exceptions-3951224}}, the invalid thread access error
has been listed as the top 3 bugs in developing a SWT application. Searching
``SWTException:Invalid thread access'' in Google returns over 11,800 entries,
consisting of numerous bug reports, forum posts, and mailing list threads on
this problem. Eclipse~\cite{eclipse}, the de-facto standard IDE for Java development,
is built on top of SWT. As eclipse became open-sourced in 2001, the invalid thread access error has
been consistently reported during the past 11 years across different products, different components, and different releases.
Searching the same ``SWTException:Invalid thread access'' keyword in eclipse's bug repository
and discussion forum returns over 2732 bug reports and 351 distinct threads, respectively. 
We further manually studied all 156 \textit{confirmed} distinct bug reports, and 
found this error has been reported in at least 20 distinct eclipse projects
and 40 distinct eclipse components. Even after over 10-year's active development,
a recent release of eclipse still contains this error (bug id: 333533, reported in 01/2011).
 Furthermore, many reported invalid thread access errors are non-trivial. It is unintuitive
to fix them. Developers usually
need non-local reasoning to find the specific UI interactions that can trigger the bug; and
some reported bugs (e.g., bug id: 51757) even took developers 2 years to fix and verify the
patch. In addition, such invalid thread access error is UI-relevant and also user-perceivable;
it cannot be recovered by eclipse itself and often terminates the whole program.
In many circumstances (as described in the bug reports),
what users can only do is to restart the application to resort to an inconsistent status.




\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

     /* In class: org.mozilla.gecko.gfx.LayerView */
68.  public LayerView(Context context, LayerController controller) \{
69.     super(context);
        ....
73.     mRenderer = new LayerRenderer(this);
74.     setRenderer(mRenderer);
        ...
     \}

     /* In Android's lib class: android.opengl.GLSurfaceView */
272. public void setRenderer(Renderer renderer) \{
        ...
282.    mGLThread = new GLThread(renderer);
283.    mGLThread.start();   
     \}

     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.    gl.glViewport(0, 0, width, height);
222.    mView.setViewportSize(new IntSize(width, height));
     \}

\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:androiderror} A real
bug reported in 11/17/2011 in Mozilla firefox release 10.0.a.rc3
for the Android platform (bugzilla ID: 703256). The \CodeIn{setRender}
method called inside \CodeIn{LayerView}'s constructor
spawns a new thread that violates the single-thread rule to inappropriately
access the GUI objects in line 222. Our tool
can find this bug and generate a warning as shown in
Figure~\ref{fig:report}.
}} %\vspace{-5mm}
\end{figure}

The invalid thread access error is not unique to the SWT framework. Other GUI frameworks
such as Android~\cite{android} also suffer from similar problems. For example, 
Figure~\ref{fig:androiderror} shows a recently reported bug on the Mozilla Firefox Android version.
In Figure~\ref{fig:androiderror}, \CodeIn{LayViewer}'s constructor calls the
\CodeIn{setRender} method (line 74), which spawns a new thread (line 283).
This newly created (non-UI) thread calls back the \CodeIn{onSurfaceChanged} method that
accesses the GUI objects at line 222, thus results in an invalid thread access error.
Compared to other reported errors, this bug is even more difficult to note, since the \CodeIn{setRender} method is in Android's
library whose source code is often not available to developers.

%It may work during development, but like most concurrent bugs, you'll start to see weird exceptions come up that seem completely unrelated, and occur non-deterministly - usually spotted AFTER you've shipped by real users. Not good.

%Also, you've got no confidence that your app will continue to work on future CPUs with more and more cores - which are more prone to encountering weird threading issues due to them being truely concurrent rather than just simulated by the OS.


\subsection{Finding Invalid Thread Access Errors}

The invalid thread access errors have significantly affect the
usability of GUIs, but have not been thoroughly studied in
the context of multithreaded GUI applications . To ensure GUIs
to behave correctly, effective
techniques must be devised to alleviate this problem.

%Effective techniques must be developed to
%find such errors.

Software testing, the most widely used method to ensure program correctness,
is often insufficient to detect such errors. That is because the space of possible interactions
with a GUI is enormous, in that each sequence of GUI events can result in
a difficult state, and each GUI event may need to be evaluated in all of
these states. It is almost impossible for testing to cover every possible
states in practice. In fact, for most reported bugs in eclipse, only very specific
UI interaction sequences can trigger the error. A large software system like eclipse
has a well-designed test suite that achieves fairly high coverage; but many
 bug-triggering UI sequences are still not covered.

Program refactoring~\cite{Mens:2004}, another popular way to improve software quality,
is also inadequate to eliminate this error.  A standard way to fix such
invalid thread access error is to replace direct GUI object accessing operations
with asynchronized message passing, to ensure GUI object are accessed in
the UI thread. For example, fixing the bug in Figure~\ref{fig:androiderror}
needs to wrap line 222 inside a \CodeIn{post} message passing method\footnote{The
\CodeIn{post} method is in class \CodeIn{android.widget.View}, providing
a standard utility to send messages to the UI-thread}, as follows:


\begin{CodeOut}
\begin{alltt}
     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.     gl.glViewport(0, 0, width, height);
         \textbf{mView.post}(new Runnable() \{
             public void run() \{
222.             mView.setViewportSize(new IntSize(width, height));
             \}
         \});
     \}
\end{alltt}
\end{CodeOut}

One may wonder that a straightforward program transformation to wrap
every possible UI-accessing operation with asynchronized message passing
may solve this problem. However, such an approach is problematic,
because using asynchronized message passing has no timing
guarantee. It is entirely possible that, in some cases, a GUI object has already been
disposed before the message sent to arrives. Thus, programmers can not use
it everywhere; instead, they must choose carefully to put it in appropriate places
with extreme caution.

%Here are a few reasons, first, for the sake of efficiency, UI must use multi-thread to perform updates and processing user requests; second, there is no language level enforcement to prevent this error; and third, programmers often forget corner cases like an event listener that may init a non-UI thread to update a UI component.
%Furthermore, asyncExec has no timing guarantee, and programmers can not use it everywhere

In this paper, we choose to use static analysis to find such potential errors.
Static analysis has several advantages while comparing to dynamic approaches like testing for this problem.
First, a static analysis can explore every path of the program without executing the code, and
thus there is no need to construct non-trivial tests and harnesses.
Second, a static analysis can soundly find potentially errors: if it
reports no warnings, the code is guaranteed to be bug-free. 


\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

   org.mozilla.gecko.gfx.LayerView.<init>(Context;LayerController)
-> android.opengl.GLSurfaceView.setRenderer(GLSurfaceView\$Renderer;)
-> java.lang.Thread.start()
-> android.opengl.GLSurfaceView\$GLThread.run()
-> android.opengl.GLSurfaceView\$GLThread.guardedRun()
-> org.mozilla.gecko.gfx.LayerRenderer.onSurfaceChanged(GL10;II)
-> org.mozilla.gecko.gfx.LayerView.setViewportSize(IntSize;)
...
-> android.view.ViewRoot.checkThread()
\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:report} A report
generated by our tool to reveal the pontential bug in
Figure~\ref{fig:androiderror}. $\rightarrow$ represents the calling relations
between methods, and \CodeIn{checkThread} is an internal utility
method in Android's library that checks whether the current thread is the
event dispatching thread before accessing a GUI object.
}} %\vspace{-5mm}
\end{figure}

We formulate finding invalid thread access as a call graph reachability
problem. Our static analysis soundly constructs a call graph and starts
to traverse every possible paths from the entry points, checking whether
there exists a path to access a GUI object from a non-UI thread. If 
a suspicious path is found,
the static analysis issues a potential warning in the form of a method
call chain from the starting point, serving as the contextual information
for developers to understand the error.

As an example, Figure~\ref{fig:report} shows a report produced
by our static analysis for the buggy code in Figure~\ref{fig:androiderror}.
This report clearly indicates how a new, non-UI thread is spawned and
accesses GUI objects. 
The generated report is a great starting point for the developers, who can
inspect the method call chain, understand how the error
is triggered, and then determine if it is a real bug.

Our static analysis is independent of the call graph construction algorithms.
However, we find existing call graph construction algorithms~\cite{} are
insufficient to build a good call graph for GUI applications in the presence
of the heavy use of reflection. To alleviate this problem,
we present a combined RTA and k-CFA call graph analysis to balance the call
graph completeness and precision. (XXXX)

\subsection{Technique Instantiation and Evaluation}

(XXX)

We instantiate our technique on four popular GUI frameworks namely SWT,
eclipse plugin, Java Swing, and Android. Instantiating the general technique
for each framework only requires few human effort. The key issue to address
is to identify UI-thread



\subsection{Contributions}

This paper makes the following contributions:

\begin{itemize}
\item \textbf{Problem.} We explicitly identify the invalid thread
access error on multithreaded GUI programs, and formulate it
as a call graph reachability problem.

\item \textbf{Technique.} We present a general technique to find
such errors. In particular, to deal with the unique features in
multithreaded GUI programs, we propose a combined RTA and k-CFA
call graph construction algorithm

\item \textbf{Implementation.} We instantiate our technique for four
popular GUI platforms: SWT, eclipse plugin, Swing, and Android. Our
tool implementation is publicly available at:
\url{http://guierrordetector.googlecode.com}

\item \textbf{Evaluation.} We performed an experiment on XXX subjects
from 4 different platforms over XXX LOC. As a result, our technique
found XXX bugs 

\end{itemize}

