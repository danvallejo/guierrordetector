\section{Introduction}

Graphical User Interfaces (GUIs) are one of the most important parts of
software. Most software developed in recent years has a GUI, and the only
way for the most end-users to interact with the software application is through
the GUI. Hence, end-user satisfaction and retention of a software application
 are largely determined by the usability and correctness of
its GUIs.

To make the GUIs more responsive and better utilize the increasingly available
computation power in the multi-core era, GUI applications often spawn separate
threads to handle time-consuming operations in the background, such as expensive
computations, I/O tasks, and network requests. Using threads for those lengthy tasks
makes a GUI active by allowing the timing of operations not delay unrelated parts of a 
GUI application.



\subsection{The Single-thread Rule}

Nowadays, many popular GUI frameworks such as Swing~\cite{swing}, SWT~\cite{swt}, Android~\cite{android},
Qt~\cite{qt}, MacOS Cocoa~\cite{macos}, and X Windows~\cite{xwindow} 
adapt the \textit{single-thread rule}:

\vspace{-2mm}

\begin{quote}
All GUI objects, including visual components and data models, must be
 accessed exclusively from the \textit{event dispatching thread}.
\end{quote}

\vspace{-2mm}

The \textit{event dispatching thread}, or called \textit{UI thread}, is a global special
thread initialized by the GUI framework, where all event-handling code
is executed. All code that interacts with GUI objects must also
execute on that thread.  There are several advantages to adapt the single-thread rule:

\begin{itemize}

\item GUI developers do not have to have an in-depth
understanding of concurrency programming. A GUI framework in which all GUI objects
fully support multithreaded access can be difficult to extend, particularly
for developers who are not expert at threads programming.

\item GUI events are dispatched in a predictable order from the same event queue.
In contrast, in a GUI framework without adapting the single-thread rule where GUI objects 
support multithreaded access, any component changes can be interleaved with event
processing at the whim of the thread scheduler. This makes program behavior comprehension hard,
 and comprehensive testing difficult or impossible. 

\item Single-thread rule incurs less overhead.
A GUI framework that attempts to carefully lock critical sections can spend a substantial
amount of time and space managing locks. Whenever the framework calls a method that might
be implemented in client code (for example, any public or protected method in a public class),
the framework must save its state and release all locks so that the client code can grab locks
if necessary. When GUI objects return from the method, the framework must re-grab their locks and
restore states. Therefore, all applications using the framework will bear the cost of this, even though most
applications do not require concurrent access to the GUI.

\end{itemize}

%Single-threaded GUI frameworks are not unique to Java; ,
%and many others are also single-threaded.

\subsection{The Invalid Thread Access Error}

Despite the convenience that the single-thread rule brings to build a
GUI framework, it pushes the thread safety burden back onto the GUI application developers,
who must make sure all GUI objects are accessed by the UI thread.

In a multithreaded GUI application, the single-thread rule can be
easily violated since a spawned non-UI thread often needs to update
the GUI  after its  task is finished.
For example, a server program can get requests from other programs
that might be running on different machines. These requests can come at any time,
and they result in one of the server's methods being invoked in some thread.
After handling the request, the GUI-update code that displays the response must be executed on the UI-thread.
If not, an \textit{invalid thread access} will error occur. In practice, such
invalid thread access error is \textit{frequent}, \textit{pervasive}, \textit{severe}.
and \textit{difficult to avoid}.

Take the popular Standard Widget Toolkit (SWT)~\cite{swt} GUI framework as an example. 
In a recent survey~\footnote{\url{http://www.slideshare.net/lakshmip/top-3-swt-exceptions-3951224}}, the invalid thread access error
has been listed as the top 3 bugs in developing a SWT application, and treated
as the source of many relevant concurrency bugs. Searching
``SWTException:Invalid thread access'' in Google returns over 11,800 entries,
consisting of numerous bug reports, forum posts, and mailing list threads on
this problem. Eclipse~\cite{eclipse}, the de-facto standard IDE for Java development,
is built on top of SWT. As eclipse became open-sourced in 2001, the invalid thread access error has
been consistently reported during the past 11 years across different products, different components, and different releases.
Searching the same ``SWTException:Invalid thread access'' keyword in eclipse's bug repository
and discussion forum returns over 2732 bug reports and 351 distinct threads, respectively. 
We further manually studied all 156 \textit{confirmed} distinct bug reports, and 
found this error has been reported in at least 20 distinct eclipse projects
and 40 distinct eclipse components. Even after over 10-year's active development,
a recent release of eclipse still contains this error (bug id: 333533, reported in 01/2011).
 Furthermore, many reported  errors are non-trivial. It is unintuitive
to fix them. Developers usually
need non-local reasoning to find the specific UI interactions that can trigger the bug; and
some reported errors (e.g., bug id: 51757) even took developers 2 years to fix it and verify the
patch. In addition, such invalid thread access error is UI-relevant and also user-perceivable;
it cannot be recovered by the program itself and often terminates the whole application.
In many circumstances as described in the bug reports,
what users can only do is to restart the application to resort to an inconsistent status.




\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

     /* In class: org.mozilla.gecko.gfx.LayerView */
68.  public LayerView(Context context, LayerController controller) \{
69.     super(context);
        ....
73.     mRenderer = new LayerRenderer(this);
74.     setRenderer(mRenderer);
        ...
     \}

     /* In Android's lib class: android.opengl.GLSurfaceView */
272. public void setRenderer(Renderer renderer) \{
        ...
282.    mGLThread = new GLThread(renderer);
283.    mGLThread.start();   
     \}

     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.    gl.glViewport(0, 0, width, height);
222.    mView.setViewportSize(new IntSize(width, height));
     \}

\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:androiderror} A real
bug reported in 11/17/2011 in Mozilla firefox release 10.0.a.rc3
for the Android platform (bugzilla ID: 703256). \CodeIn{LayerView}'s constructor
calls method \CodeIn{setRender} that
spawns a new thread at line 283. The new thread calls back method
\CodeIn{onSurfaceChanged} that access GUI objects at line 222, and
causes an invalid thread access error.
Our tool
can find this error and generate a warning as shown in
Figure~\ref{fig:report}.
}} %\vspace{-5mm}
\end{figure}

The invalid thread access error is not unique to the SWT framework. Other recent GUI frameworks
like Android~\cite{android} also suffer from similar problems. For example, 
Figure~\ref{fig:androiderror} shows a recently reported bug on the Mozilla Firefox Android version.
In Figure~\ref{fig:androiderror}, \CodeIn{LayViewer}'s constructor calls the
\CodeIn{setRender} method (line 74), which spawns a new thread (line 283).
This newly created, non-UI thread calls back the \CodeIn{onSurfaceChanged} method that
accesses the GUI objects at line 222, causing an invalid thread access error.
Compared to other reported errors, this bug is even more difficult to note, 
since the code that spawns a new thread inside the \CodeIn{setRender} method is
in Android's library whose source code is often not available to developers.

%It may work during development, but like most concurrent bugs, you'll start to see weird exceptions come up that seem completely unrelated, and occur non-deterministly - usually spotted AFTER you've shipped by real users. Not good.

%Also, you've got no confidence that your app will continue to work on future CPUs with more and more cores - which are more prone to encountering weird threading issues due to them being truely concurrent rather than just simulated by the OS.


\subsection{Finding Invalid Thread Access Errors}

The invalid thread access errors have significantly affect the
usability of GUIs, but have not been thoroughly studied in
the context of multithreaded GUI applications . To ensure GUIs
to behave correctly, effective
techniques must be developed to alleviate this problem.

%Effective techniques must be developed to
%find such errors.

Software testing, the most widely used method to ensure program correctness,
is insufficient to detect such errors. That is because the space of possible interactions
with a GUI is enormous, in that each sequence of GUI events can result in
a difficult state, and each GUI event may need to be evaluated in all of
these states. It is almost impossible for testing to cover every possible
states. In fact, for a widely-used software system like eclipse
often has a well-designed test suite that achieves fairly high coverage; but many
 bug-triggering UI sequences are still not covered.

Program refactoring~\cite{Mens:2004}, another popular way to improve software quality,
is also inadequate to eliminate this error.  A standard way to fix such
invalid thread access error is to replace direct GUI object accessing code 
with asynchronized message passing, to ensure GUI object are accessed in
the UI thread. For example, fixing the bug in Figure~\ref{fig:androiderror}
needs to wrap line 222 inside a \CodeIn{post} message passing method\footnote{The
\CodeIn{post} method in class \CodeIn{android.widget.View} is a
a standard way to send messages to the UI-thread}, as follows:


\begin{CodeOut}
\begin{alltt}
     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.     gl.glViewport(0, 0, width, height);
         \textbf{mView.post}(new Runnable() \{
             public void run() \{
222.             mView.setViewportSize(new IntSize(width, height));
             \}
         \});
     \}
\end{alltt}
\end{CodeOut}

One may wonder that a straightforward program transformation to wrap
every possible UI-accessing operation with asynchronized message passing
may solve this problem. However, such an approach is problematic,
because using asynchronized message passing has no timing
guarantee. It is entirely possible that, in some cases, a GUI object has already been
disposed before the message sent to arrives. Thus, programmers can not use
it everywhere; instead, they must choose carefully to put it in appropriate places
with extreme caution.

%Here are a few reasons, first, for the sake of efficiency, UI must use multi-thread to perform updates and processing user requests; second, there is no language level enforcement to prevent this error; and third, programmers often forget corner cases like an event listener that may init a non-UI thread to update a UI component.
%Furthermore, asyncExec has no timing guarantee, and programmers can not use it everywhere

In this paper, we choose to use static analysis to find such potential errors.
Static analysis has two attractive advantages while comparing to dynamic approaches such as
 testing.
First, a static analysis can explore every path of the program without executing the code, and
thus there is no need to construct non-trivial tests and harnesses.
Second, a static analysis can soundly find potentially errors: if it
reports no warnings, the code is guaranteed to be bug-free. 


\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

   org.mozilla.gecko.gfx.LayerView.<init>(Context;LayerController)
-> android.opengl.GLSurfaceView.setRenderer(GLSurfaceView\$Renderer;)
-> java.lang.Thread.start()
-> android.opengl.GLSurfaceView\$GLThread.run()
-> android.opengl.GLSurfaceView\$GLThread.guardedRun()
-> org.mozilla.gecko.gfx.LayerRenderer.onSurfaceChanged(GL10;II)
-> org.mozilla.gecko.gfx.LayerView.setViewportSize(IntSize;)
...
-> android.view.ViewRoot.checkThread()
\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:report} A report
generated by our tool to reveal the pontential error in
Figure~\ref{fig:androiderror}. This report indicates a 
full method call chain that causes the error. $\rightarrow$ represents
the call relationship
between methods, and \CodeIn{checkThread} is an Android library
method  that checks whether the current thread is the
event dispatching thread before accessing a GUI object.
}} %\vspace{-5mm}
\end{figure}

We formulate finding invalid thread access as a call graph reachability
problem. Given a call graph, our technique traverses
every possible paths from its entry nodes, checking whether
there exists a path to access a GUI object from a non-UI thread. If 
a suspicious path is found,
the static analysis issues a potential warning in the form of a method
call chain from the starting point, serving as the contextual information
for developers to understand the error.
As an example, Figure~\ref{fig:report} shows a report produced
by our static analysis for the buggy code in Figure~\ref{fig:androiderror}.
This report clearly indicates how a new, non-UI thread is spawned and
accesses GUI objects. 
The generated report is a great starting point for the developers, who can
inspect the method call chain, understand how the error
is triggered, and then determine if it is a real bug.

Our static analysis is independent of the call graph construction algorithms.
Given a sound call graph, our analysis is sound in that it does
not miss true positives. We note, however, that computing a sound
call graph for GUI applications in the presence of reflection,
is non-trivial.
Existing call graph construction algorithms such as RTA~\cite{} and k-CFA~\cite{}
either suffer from the problem of imprecision or incompleteness .
To alleviate this problem,
we present a combined RTA and k-CFA call graph construction algorithm, and
also compare its usefulness with other algorithms in  our experiments.

\subsection{Technique Instantiation and Evaluation}


We instantiate our technique for four popular GUI frameworks namely SWT,
eclipse plugin environment, Java Swing, and Android. Swing and SWT are
two dominating GUI frameworks in developing desktop Java applications.
Eclipse and its plugin development envrionment is the de-facto standard
IDE for Java. Android market share reaches 56\% in the mobile computing
world as of Sep 2011, and becomes the No. 1 platform for mobile applications.
Instantiating the general technique for each framework only requires few
human effort. The primary framework-specific part is to specify
the \textit{UI thread} and \textit{call graph entry nodes}.

We further implement a prototype tool that supports detecting invalid
thread access errors in the above four GUI frameworks, and evaluate
it on XXX subjects over XXX LOC. The experiment results demonstrate
the effectiveness of the proposed technique. Our tool found XXX
from XXX subjects on all supported GUI frameworks with an acceptable
false positives.




\subsection{Contributions}

This paper makes the following contributions:

\begin{itemize}
\item \textbf{Problem.} We explicitly identify the invalid thread
access error on multithreaded GUI programs.
%, and formulate it
%as a call graph reachability problem.

\item \textbf{Technique.} We formulate finding
the invalid thread access error as a call graph reachability problem,
and present a general technique to find such errors. 
In particular, to deal with the unique features in
multithreaded GUI programs, we propose a combined RTA and k-CFA
call graph construction algorithm (Section~\ref{sec:technique}).

\item \textbf{Implementation.} We implement our technique, and
instantiate it for four
popular GUI platforms: SWT, eclipse plugin, Swing, and Android (Section~\ref{sec:implementation}). Our
tool implementation is publicly available at:
\url{http://guierrordetector.googlecode.com}

\item \textbf{Evaluation.} We performed an experiment on XXX subjects
from 4 different platforms over XXX LOC. As a result, our technique
found XXX bugs (Section~\ref{sec:evaluation}).

\end{itemize}

