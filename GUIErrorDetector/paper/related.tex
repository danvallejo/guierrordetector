
\tinystep
\section{Related Work}

Work related to this paper falls into three main categories; (1)
analyzing and testing GUI applications; (2)
bug finding techniques for multithreaded programs; and (3)
call graph construction algorithms.

\tinystep
\subsection{Analyzing and Testing GUI Applications}
%\vspace{1mm}

%\noindent \textit{\textbf{Analysis and Testing for GUI Applications}}
Automated GUI testing is a challenging task~\cite{Bertolino:2007:STR:1253532.1254712,
Harrold:2000:TR:336512.336532}.
Various techniques automate GUI testing including
%model creation
%(for model-based testing)~\cite{androidtesting}, %, Xie:2006:MTC:1172962.1172990},
test generation~\cite{YuanMemonICSE2007},
test oracle creation~\cite{MemonFSE2000}, test execution~\cite{YuanCohenMemonTSE2011},
and test script repairing~\cite{Huang:2010:RGT:1828417.1828465, Daniel:2011:AGR:2002931.2002937}.
For example,
Guitar~\cite{YuanCohenMemonTSE2011, YuanMemonICSE2007}
is a GUI testing framework for Java and Microsoft Windows applications. 
Yuan and Memon~\cite{YuanMemonICSE2007} generated event-sequence-based test cases for GUI
programs using a structural event generation graph. 
However, testing is often insufficient to detect many potential
errors in a GUI application due to the huge space of possible UI interactions.
%The large number of possible interactions
%requires a large number of test inputs that require substantial human effort.
In contrast, a static analysis can explore all paths to find potential errors missed by testing.
Compared to software testing, a static analysis tool such as ours may
report false positives and redundant warnings due to its conservative nature.
In our experiments, simple error filters reduced the number of warnings to
an acceptable level.


Michail and Xie~\cite{michail05:helping} proposed a tool-based approach to help users avoid bugs
in GUI applications. Their approach monitors a user's action in the background,
and gives a warning as well as the opportunity to abort the action, when
a user attempts an action that has led to problems in the past. 
Their work aims to prevent an existing bug from happening again.
By contrast, our work aims to find unknown errors.


Recently, Payet and Spoto~\cite{Payet:2011:SAA:2032266.2032299} presented a static
analysis framework for Android programs based on  abstract
interpretation. Their framework focuses on the Android platform, and
 consists of 7 existing static analyses such as
nullness analysis, class analysis, and termination analysis.  However,
their framework does not support detecting invalid-thread-access
errors, and uses a quite different abstraction than ours.
To the best of our knowledge, we are the first to address the invalid
thread access error detection problem for multithreaded GUI applications, and
our core technique has been tailored for four GUI frameworks.


\tinystep
\subsection{Finding Bugs in Multithreaded Programs}

%\vspace{1mm}

%\noindent \textit{\textbf{Finding Bugs in Multithreaded Programs}}
A rich body of techniques have been developed to detect bugs in multithreaded programs~\cite{Huang:2011:PPC:2001420.2001438, Weeratunge:2010, Huang:2011:EST}.
Static analysis tools such as Chord~\cite{Naik:2006}
explore multithreaded programs. Runtime
analysis tools such as Eraser~\cite{Savage:1997}  dynamically detect concurrency bugs using lockset
algorithms or some criteria-based automata. 
More recently, Goldilocks~\cite{Elmas:2007} uses a
hybrid model that combines the happens-before and lock-based
approaches to identify data races based on an execution.
However, finding invalid-thread-access errors is quite different than detecting data races.
A data race occurs when two concurrent threads access
a shared variable and when at least one access is a write and the threads
use no explicit mechanism to prevent the accesses from being simultaneous. In contrast,
an invalid thread access error occurs when a non-UI thread accesses (reads or writes) a GUI object.
Unlike detecting data races, finding an invalid-thread-access error does not require monitoring every shared-memory
reference to verify that consistent locking behavior is observed among different threads.
A technique only needs to track whether a non-UI thread can accesses a GUI object or not,
and is much cheaper. Leveraging data race detection to 
improve our technique is future work.


An alternative way to find bugs in multithreaded programs is using model checking~\cite{Nori:2010:ESO, Inverardi:2000, Siegel:2008}.
By exhaustively exploring the thread scheduling space, a model checker can
report counterexamples as bug reports.
Unfortunately, due to the exponential size of the search space,
it is hard for model checking approaches to scale to a realistic multithreaded GUI application
 without compromising the error detection capability. 
We are not aware of any software model checking approach that scales to programs
as large as those used in our experiments (including the library code).
The technique presented in this paper is specifically designed to find invalid thread
errors instead of being a general property checking tool. 
It chooses the call graph as a coarse-grained program representation with a
set of error filters, to achieve good scalability with reasonable accuracy.

%For this reason,
%our technique achieves good scalability with reasonable precision.

\tinystep

\subsection{Call Graph Construction Algorithms}
%\vspace{1mm}

%\noindent \textit{\textbf{Call Graph Construction Algorithms}}
We briefly mention some call graph construction
algorithms for Java. Grove et al.~\cite{kcfa} described a unified
framework for expressing call graph construction algorithms, and
studied different instantiations of the framework.
Tip and Palsberg~\cite{xta} quantitatively compared
several low-cost call graph construction algorithms for Java.
Sundaresan et al.~\cite{Sundaresan:2000} went beyond the
RTA~\cite{rta} approach and used type propagation
to build a more precise call graph.  However,
those algorithms do not build a complete call graph in the presence of reflection.
As reflected in our experiments, using standard call graph algorithms
misses errors in some Android applications.


Livshits et al.~\cite{Livshits:2005} presented a static analysis
to reason about reflective calls. The analysis
attempts to infer additional information stored in string constants to resolve
reflective calls statically. Their approach focuses on standard Java
reflection calls (e.g., \CodeIn{Class.forName}) instead of
framework-specific ones (e.g., \CodeIn{View.find-\\ViewById}).
The standard call graph algorithms implemented in WALA, which we used
in our experiments, actually handles standard Java
reflection calls as~\cite{Livshits:2005} does, but still fails to build
a sufficiently complete call graph for
Android applications. TamiFlex~\cite{Bodden:2011}, a pure dynamic
approach, records all reflectively-created class instances
by intercepting JVM system calls, and re-inserts those recorded 
class into a program. However, TamiFlex requires a set of representative
program executions and is only sound with respect to the given executions.
Perhaps the closest work to our call graph
construction algorithm is Payet and Spoto's Julia
system~\cite{Payet:2011:SAA:2032266.2032299}. The Julia system
needs to first instrument Android's library code that performs the XML inflation,
and then replaces the \CodeIn{findViewById} call with the corresponding
object creation expressions. In addition, the Julia system does not handle
native methods when building call graphs. In contrast, our technique provides
annotation support for native methods, and our tool does not need a separate
pass of off-line instrumentation. The reflection-aware call graph is created
online by intercepting the standard call graph construction process.





%There are few algorithms have been studied to construct call
%A recent paper by Hirzel, Diwan, and Hind addresses the issues of dynamic
%class loading, native methods, and reflection in order to deal with the full complexity
%of Java in the implementation of a common pointer analysis [5]. Their
%approach involves converting the pointer analysis [6] into an online algorithm:
%they add constraints between analysis nodes as they are discovered at runtime.
%Newly generated constraints cause re-computation and the results are propagated
%to analysis clients such as a method inliner and a garbage collector at
%runtime. Their approach leverages the class hierarchy analysis (CHA) to update
%the call graph. Our technique uses a more precise pointer analysis-based
%approach to call graph construction.


 
