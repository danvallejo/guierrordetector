\section{Technique}
\label{sec:technique}

We first give a high-level formulation of the problem, then present
the error detection algorithm. Finally, we show how to instantiate
the error algorithm for different GUI frameworks.


\subsection{Problem Formulation}

This section formulates the problem. We first define the
notations of \textit{UI thread}, \textit{non-UI threads},
\textit{UI-accessing methods},
 \textit{safe UI methods}, and \textit{invalid thread access error}, and
state two assumptions we make with regard to error detection.

\noindent {\textsc{\textbf{Definition 1 (UI Thread).}}} {The UI thread
is a special thread created by the GUI framework during
GUI initialization. After the GUI becomes visible, the UI thread
takes charge of the application to handle events from the GUI,
and spawns new threads to process lengthy operations in the background. }\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 1.}}} {We assume that each multithreaded
GUI application has a single global UI thread. This is true for applications
built on top of GUI frameworks adopting the single-GUI-thread rule. The
only exception is that 
 an application may fork a new process to launch another
application with its own UI thread. In that case, we require the
launched application to be analyzed separately.}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 2 (non-UI Thread).}}} {Any other
threads except for the UI thread in a multithreaded GUI application
 are called non-UI threads.}\vspace{1mm}

\noindent {\textsc{\textbf{Assumption 2.}}} { We assume that each non-UI
thread is spawned by the UI thread. Under this assumption,
we ignore all non-UI threads created by the GUI framework
before the UI thread has been initialized. That is, all post-initialization
GUI work naturally occurs in the UI thread. Once the GUI is visible, the
application is driven by events, which are always handled in the UI thread.
We believe this assumption is reasonable, since if a non-UI thread 
spawned during pre-initialization GUI work accesses a GUI object, an exception becomes
immediately apparent and the whole application may abort even before the
GUI is visible. This is highly unlikely for realistic GUI
applications.
}\vspace{1mm}

\noindent {\textsc{\textbf{Definition 3 (UI-Accessing Methods).}}} { A method
whose execution may read or write a UI object is called a UI-accessing method.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 4 (Safe UI Methods).}}} {GUI frameworks that
adopt the single-GUI-thread rule must provide methods to permit non-UI threads
to run code in the UI thread. We call such methods \textit{safe UI methods}, since
they can be invoked safely by any thread.}\vspace{1mm}

\noindent  {\textsc{\textbf{Definition 5 (Invalid Thread Access).}}} {An invalid
thread access error occurs when the UI thread may spawn a non-UI thread, and there
exists a path from the non-UI thread's \CodeIn{start} method to any UI-accessing method
without going through any safe UI method. }\vspace{2mm}

At a high level, to detect an invalid thread access error, an analysis needs to track all
non-UI threads spawned by the UI thread, and check whether those non-UI threads
may invoke a UI-accessing method.

\subsection{Error Detection Algorithm}

The algorithm for detecting potential invalid thread access errors
is shown in Figure~\ref{fig:detectalgorithm}. Our algorithm uses a
static call graph as the program representation for a multithreaded
GUI application. A Java call graph represents calling relationships
between methods. Specifically, each node represents a method and each
edge ($f$, $g$) indicates that method $f$ may call method $g$.
A theoretically ideal call graph can be defined as the union of the
dynamic call graphs over all possible executions of the program. 
A conservative, or sound, static call graph is a superset of
the ideal call graph; it over-approximates the
dynamic call graph of every possible execution. 
In an object-oriented programming language like
Java, a method is the basic logic unit in a program. Reporting
potential errors at the method level can be sufficient in most cases.
%Thus, we believe using the call graph is well suited for this problem while
%compared with other program representations like control flow graph or
%program dependence graph. 


Our algorithm in Figure~\ref{fig:detectalgorithm} %works as follows. It
first constructs a static call graph for the tested program (line 2),
then specifies entry nodes, UI-accessing nodes, and safe UI nodes
for it on line 3, 4, and 5, respectively. Lines 3--5 are GUI framework-specific.
As an example, for a SWT desktop application, the entry nodes include
the single main method, UI-accessing nodes include methods
\CodeIn{Display.checkWidget} and \CodeIn{Display.checkDevice},
and safe UI methods include two SWT helper methods \CodeIn{Display.asyncExec}  and
\CodeIn{Display.syncExec} for message passing. The detailed instantiation
for each supported framework is explained in Section~\ref{sec:platforms}.

The algorithm first performs graph traversal to find all reachable \CodeIn{Thread.start()}
nodes from the entry nodes (line 6).
%For each entry node, the algorithm uses standard Breadth First Search (BFS)
%to find all reachable \CodeIn{Thread.start()} nodes (line 7).
Each \CodeIn{Thread.start()} node in a call graph indicates that a new,
non-UI thread is spawned.  The \CodeIn{Thread.start()}
nodes act as the sources in the main graph traversal.
The algorithm uses BFS to search for reachable UI-accessing
methods (lines 10 -- 24).
The algorithm stops the traversal if it reaches a UI-accessing
method (lines 16 -- 18) or a safe UI method (lines 19, 20).
%Specifically, it uses a queue to keep track of the nodes to be visited (line 7),
%and stores all visited nodes to avoid infinite loop (line 8).
%The algorithm checks every successive node to be visited (line 16):
%it reports an error if that node is a UI-accessing method (lines 18, 19), or skips
%it if it is a safe UI method (lines 20, 21), or simply keeps traversing otherwise (line 23).

The error message created by the method \CodeIn{createErrorReport} on line 17
includes the method call chain from the entry node to the UI-accessing node
as the error report. For brevity, we do not show the data structures that store
the current call chain.
Figure~\ref{fig:report} shows a method call chain from the entry
node \CodeIn{LayerView.<init>} to the UI-accessing node \CodeIn{ViewRoot}.\CodeIn{checkThread}.
%Note that when the algorithm determines that a UI-accessing method may be invoked
%by a non-UI thread, it computes a method call chain from the entry node to
%the UI-accessing node as the error report.
% does that. 




\begin{figure}[t]
\textbf{Input}: a Java program $\mathit{P}$\\
\textbf{Output}: a set of potential invalid thread access errors\\
%\textbf{Auxiliary Methods:}\\
%getSuccNodes($\mathit{g}$, $\mathit{n}$): return node $\mathit{n}$'s successive
%nodes in the graph $\mathit{g}$\\
\vspace{-4mm}
\begin{algorithmic}[1]
\STATE $\mathit{errors}$ $\leftarrow$ $\emptyset$ 
\STATE $\mathit{cg}$ $\leftarrow$ constructCallGraph($\mathit{P}$)
\STATE $\mathit{entryNodes}$ $\leftarrow$ getEntryNodes($\mathit{cg}$)
\STATE $\mathit{uiAccessingNodes}$ $\leftarrow$ getUIAccessNodes($\mathit{cg}$)
\STATE $\mathit{safeUINodes}$ $\leftarrow$ getSafeNodes($\mathit{cg}$)\\
\COMMENT{get all reachable \CodeIn{thread.start()} nodes from entry nodes}
\STATE $\mathit{threadStarts}$ $\leftarrow$ $\bigcup_{entry \in entryNodes}$ getReachableStarts($\mathit{entry}$)
\COMMENT{keep the nodes to be visited next in a worklist}
\STATE $\mathit{worklist}$ $\leftarrow$ an empty queue\\
\STATE $\mathit{worklist}$.enqueueAll($\mathit{threadStarts}$)
\STATE $\mathit{visited}$ $\leftarrow$ $\emptyset$
\WHILE{$\mathit{worklist}$.isNotEmpty()}
\STATE $\mathit{node}$ $\leftarrow$ $\mathit{worklist}$.dequeue()
\IF{$\mathit{node}$ $\in$ $\mathit{visited}$}
\STATE continue
\ENDIF
\STATE $\mathit{visited}$ $\leftarrow$ $\mathit{visited}$ $\cup$ $\mathit{node}$
\IF{$\mathit{node}$ $\in$ $\mathit{uiAccessingNodes}$}
\STATE $\mathit{newError}$ $\leftarrow$ createErrorReport($\mathit{node}$)
\STATE $\mathit{errors}$ $\leftarrow$ $\mathit{errors}$ $\cup$ $\mathit{newError}$
\ELSIF{$\mathit{node}$ $\in$ $\mathit{safeUINodes}$}
\STATE continue
\ELSE
\STATE $\mathit{worklist}$.enqueueAll(getSuccNodes($\mathit{cg}$, $\mathit{node}$))
\ENDIF 
\ENDWHILE
\RETURN $errors$
%\ENDWHILE
\vspace{-2mm}
\end{algorithmic}
\caption{Algorithm for detecting invalid thread access errors in multithreaded GUI programs. 
Any call graph construction algorithm can be used (line 2). The algorithm
is parameterized by the three methods in lines 3--5 which are specific to each GUI framework
 as described in Section~\ref{sec:platforms}.
} \label{fig:detectalgorithm}
\end{figure}

The algorithm in Figure~\ref{fig:detectalgorithm} uses BFS to search
for potential error-revealing paths, since BFS always returns the
shortest path to the UI-accessing node, permitting
smaller error reports. However,
other graph search strategies such as Depath-First Search (DFS) or
exhaustive path search can also be employed. In our experiment (Section~\ref{sec:search}),
we empirically compared three different graph search strategies, and demonstrated that
using BFS, the algorithm found more errors than DFS and
exhaustive path search.

Given a sound call graph, our algorithm is sound in that it does not
miss true positives. We note, however, that computing a sound
call graph in the presence of reflection is non-trivial. 
To alleviate this problem, we next proposed a reflection-aware call graph
construction algorithm in Section~\ref{sec:cg}.

\subsubsection{Reflection-aware Call Graph Construction}
\label{sec:cg}

%In OO program, translate k-CFA as:
%k-call-site sensitive interprocedural pointer
%analysis with a k-context-sensitive heap and onthe-
%fly call-graph construction
% 

\begin{figure}[t]
%\centering
\begin{CodeOut}
\begin{alltt}
<LinearLayout>
    <Button android:id="@+id/\textbf{button\_id}" android:text="A Button" />
</LinearLayout>

1. public class MyActivity extends Activity \{
2.    @Override
3.    public void onCreate(Bundle savedInstanceState) \{
4.        super.onCreate(savedInstanceState);
5.        setContentView(R.layout.main);
6.        Button button = (Button) findViewById(R.id.\textbf{button\_id});
7.        button.setOnClickListener(new Button.OnClickListener() \{
8.            @Override
9.            public void onClick(View v) \{
10.               button.setText("Button Clicked.");
11.           \}
12.       \});
13.   \}
14. \}
\end{alltt}
\end{CodeOut}
\vspace*{-3.0ex} \caption{Sample GUI application code on the Android platform. The layout
XML file (the top) specifies a Button object declaratively, 
and the Java code (the bottom)
first loads the XML file (line 5) and then uses reflection to create
a Button object by its ID (line 6, the \CodeIn{findViewById} method).}
\label{fig:sampleandroid}
\end{figure}



\begin{figure}[t]
\textbf{Input}: a Java program $\mathit{P}$\\
\textbf{Output}: a call graph $\mathit{cg}$\\
\vspace{-5mm}
\begin{algorithmic}[1]
\FOR{each $\mathit{statement}$ in $\mathit{P}$}
\IF{isReflectionCall($statement$)}
\STATE $\mathit{objectSet}$ $\leftarrow$ getAllObjectsThatMaybeCreated($\mathit{statement}$)
\STATE $\mathit{newStmt}$ $\leftarrow$ createObjectCreationStatement($\mathit{objectSet}$)
\STATE replace $\mathit{statement}$ with $\mathit{newStmt}$
\ENDIF
\ENDFOR
\STATE $\mathit{cg}$ $\leftarrow$ constructCallGraph($\mathit{P}$)
\RETURN $\mathit{cg}$
%\ENDWHILE
\end{algorithmic}
\vspace{-3mm}
\caption{A reflection-aware call graph construction algorithm. Lines
1--7 are a simple program transformation to replace reflection calls
with object creations, and line 8 builds the call graph using
an existing call graph construction algorithm. This algorithm
is parameterized by two methods on lines 2 and 3. 
How to instantiate it for the Android framework is presented in Section~\ref{sec:cg}.
%This algorithm is parameterized by the call graph construction
%algorithm on line 8, in which any existing algorithm can be used.
} 
\label{fig:cgalgorithm}
\end{figure}

%GUI applications tend to use reflection intensively. In particular,
GUI applications built on top of the Android framework
use configuration files and reflection to specify GUI layout.
As a result, call graph construction algorithms such as RTA~\cite{rta}
and k-CFA~\cite{kcfa} fail to build a sufficiently complete call graph.
The example code in Figure~\ref{fig:sampleandroid} from an Android application
 illustrates the limitations.
In Figure~\ref{fig:sampleandroid}, line 6 uses reflection to create a \CodeIn{Button}
object by looking up its id declared in the associated XML file. When this button
is clicked, its event handling code (lines 9--11) updates the text.
%d caches
%the current view to a list declared at line 2.

When analyzing the code in Figure~\ref{fig:sampleandroid}, existing call graph algorithms
fail to conclude that the variable \CodeIn{button} declared at line 6
points to a \textit{non-null} \CodeIn{Button} object due to its limitation in deal with the
reflection call \CodeIn{findViewById}. As a result, the built 
call graph will exclude the calling edge corresponding to the
\CodeIn{setText} method call on line 10. 

%Existing call graph algorithms failed either suffer from the problem of incompleteness
%or imprecision. The k-CFA algorithm performs points-to analysis with call
%graph construction interleavingly, and maintains a value set for every expression.
%For example, it concludes that variable \CodeIn{cachedViews} can only point
%to a \CodeIn{LinkedList} object and the method call \CodeIn{add} at line 12
%can only correspond to \CodeIn{LinkedList.add}. However, k-CFA fails to
%conclude that variable \CodeIn{button} declared at line 7 points to
%a \CodeIn{Button} object due to its limitation in dealing with reflection. Thus, k-CFA
%may miss the call graph edge corresponding to the method call \CodeIn{setText} at line 11. 
%On the other hand, using a coarse-grained algorithm like RTA~\cite{} can not still
%fully solve this problem. RTA adds an edge for a method invocation 
%to the call graph if an object of the receiver's type (or subtype)
%has been created.  By explicitly specifying that all GUI classes declared in the XML file will be created,
%RTA maintains a global value set for those GUI object type, and  adds a
%call edge \CodeIn{setText} to the call graph. However, RTA introduces 
%unnecessary precision loss: it may
%may conclude that the \CodeIn{cachedViews} variable at line 2
%point to any created \CodeIn{List} objects created somewhere else in the program, despite the
%fact that \CodeIn{cachedViews} can only be a \CodeIn{LinkedList} object.


To address this limitation, we present an algorithm to construct
a reflection-aware call graph based on a simple program transformation.
The basic idea is to replace reflection calls with explicit object
creation statements, pretending that the corresponding concrete object
has been created.  The algorithm is shown in Figure~\ref{fig:cgalgorithm}.
It consists of two steps. The first step (lines 1 -- 7) is a simple program
transformation to replace reflection calls with object creation statements, and
the second step (line 8) uses an existing call graph construction algorithm
to build the graph on the transformed program. In our context,
a reflection call represents a framework-specific helper method invocation
that uses Java reflection to create desirable objects, such as
the \CodeIn{findViewById} method in Android applications, instead
of the methods in the \CodeIn{java.lang.reflection} package.
%In Figure~\ref{fig:cgalgorithm}, lines 1--7 show
%the first step of program transformation. The algorithm iterates through every statement
%in an analyzed program.
When it sees a reflection call, the algorithm
determines a set of possible objects that might be created.
After that, the algorithm creates a statement that non-deterministically
returns a new object from the object set.
%Line 8 is the second step
%to build a call graph on the transformed program. 

This algorithm is parameterized by two methods on
lines 2 and 3. When instantiated for the Android framework,
the predicate isReflectionCall on line 2 returns true
if the $statement$ is a \CodeIn{findViewById(id)} method call, and the method
getAllObjectsThatMaybeCreated on line 3 parses the associated XML configuration
file in an Android application to extract the class declaration
 corresponding to the given \CodeIn{id} value. If the \CodeIn{id}
value is dynamically generated, this method will conservatively
return instances of all subclasses of the declared type.
%On line 8, any existing call graph construction algorithm can be applied.

Take the code in Figure~\ref{fig:sampleandroid} as an example.
When the algorithm sees the reflection call
\CodeIn{findViewById(R.id.button\_id)}, it
parses the XML configuration file to determine that the \CodeIn{button\_id}
value is mapped to a \CodeIn{Button} instance. Then, it
replaces the reflection call
with an explicit object creation statement: \CodeIn{new Button(null)}.
After that, the algorithm employs existing call graph construction
algorithms to analyze the transformed program, and permits them
to add the call edge \CodeIn{setText} to the resulting graph.

As demonstrated in our experiments, using this reflection-aware call
graph construction algorithm helps in detecting errors
in Android applications (Section~\ref{sec:evaluation}).

% combined RTA and k-CFA
%call graph construction algorithm as shown in Figure~\ref{fig:cgalgorithm}.
%The algorithm shares the same spirit as k-CFA to maintain a value set
%for each expression. However, the only difference is that our
%algorithm uses a RTA-style treatment for constructing the value set for
%GUI classes: it parses the XML configuration file and explicitly
%adds a raw object to each declared GUI variable's value set. Thus,
%For the example in Figure~\ref{fig:sampleandroid}, this
%combined algorithm concludes that a \CodeIn{Button} object has been
%created at line 7 and then adds the call edge \CodeIn{setText} to the
%graph. It also concludes that the \CodeIn{cachedViews} variable can only
%point to a \CodeIn{LinkedList} object, avoiding unnecessary precision loss.


\subsubsection{Annotation for Native Methods}
\label{sec:annotation}

A GUI application may also use native methods to interact with the underlying
operating system or platforms. However, native methods are often
beyond the ability of a static analysis but should be considered to make
the call graph more complete. To do so, we provide an annotation \CodeIn{@CalledByNativeMethods}
for users to specify which native methods may call the current method. For example,
the following code snippet indicates that native methods \CodeIn{native1()} and \CodeIn{native2()}
may call method \CodeIn{javaMethod()}.

%\noindent 
\CodeIn{@CalledByNativeMethods(callers=\{"native1", "native2"\})}

%\noindent
\CodeIn{public void javaMethod() \{ ... \}}


Our static analysis takes the call relationship specified by this
annotation into consideration when traversing the call graph. 
Adding annotations for native methods is optional and requires manual effort.
In our experiments, 1 out of 9 programs uses native methods. We manually
searched the source files, inspected the code to determine possible target methods
that may be called by a native method, and added 7 annotations for this program.
We found such an annotation was useful: one error
can only be reported with using the user-provided annotations.

\subsubsection{Heuristic Filtering}
\label{sec:heuristic}

A static analysis can exhaustively check possible error paths; but may report
paths that do not actually exist (false positives) or multiple paths
 that have the same error cause (redundant warnings). We devise
5 heuristic filters below to remove likely false positives and redundant warnings.
The first two are for eliminating false positives, while the
other three are for reducing redundant warnings.

%To remove those 
%The potentially huge volume of
%reported warnings impose great burden for programmers to check
%its validity. 


%\begin{enumerate}

%\item
\textbf{1. Filter Reports Containing Library Calls}. A
method call chain containing certain library calls
like \CodeIn{Runtime.}\CodeIn{shutDown} are unlikely to
be buggy. For example, the \CodeIn{Runtime.}\CodeIn{shutDown}
method is called when JVM terminates, and uses multithreading
to dispose all GUI objects when the program exits.
We encoded a list of common library calls by proposing
a basic set of library calls that seemed natural and
generally applicable, based on our programming experience.
We later added other calls we found helpful in analyzing
programs and that we believed would be generally useful.
%We encode a list of common library calls, and remove
%a reported warning if it contains one of them.
%Method call chain involves typical
%system methods like \CodeIn{toString} are unlikely to reveal a real bug.

%\item
\textbf{2. Filter Reports With User-Annotated Methods}. Besides general
library calls, users are also permitted to explicitly annotate methods
that will never trigger an error.
For example, the Android GUI framework provides a utility method 
\CodeIn{runOnUIThread} to check whether the current thread is the UI thread
before executing the code. If the current thread is not the UI thread,
this method will be executed on the UI thread via message passing.
Thus, a reported method call chain containing an annotated 
can be safely removed. We produced the list of annotated methods
during analyzing programs on different GUI frameworks; we did this
only between experiments rather than biasing experiments by tuning
our tool to specific programs.

%\item
\textbf{3. Filter Lexically Redundant Reports}. One reported method call
chain can lexically subsume another one. For example, suppose that two
reported method call chains: \CodeIn{a()} $\rightarrow$ \CodeIn{b()}
$\rightarrow$ \CodeIn{c()} and 
\CodeIn{d()} $\rightarrow$ \CodeIn{a()} $\rightarrow$ \CodeIn{b()} $\rightarrow$ \CodeIn{c()}
both lead to a potential error, since $\CodeIn{d()}$ and \CodeIn{a()}
are two distinct entry methods. The second call chain should
be removed and would not reduce the error detection capability, since
the first chain reveals the same error and is shorter 
for programmers to interpret.


%\item
\textbf{4. Filter Report With the Same Head Methods from the Entry Node to \CodeIn{Thread.start()}}. A method can call
multiple methods that access GUI objects, such as:
\vspace{-1mm}
\begin{CodeOut}
\begin{alltt}
     public void m() \{
         accessUIObject1();
         accessUIObject2();
     \}
\end{alltt}
\end{CodeOut}
If method \CodeIn{m()} is invoked by a non-UI thread, method call chains
only different at the last few method nodes may be reported separately, such as:

\CodeIn{a()} $\rightarrow$ ...\CodeIn{Thread.start()} ... $\rightarrow$ \CodeIn{m()} $\rightarrow$ \CodeIn{accessUIObject1()} ...

\CodeIn{a()} $\rightarrow$ ...\CodeIn{Thread.start()} ... $\rightarrow$ \CodeIn{m()} $\rightarrow$ \CodeIn{accessUIObject2()} ...

In fact, these two chains may have the same error root: knowning that
method \CodeIn{m()} is called by a non-UI thread is sufficient to understand
the error.
This filter compares two reported chains that have the same
head methods from the entry node to \CodeIn{Thread}.\CodeIn{start()},
and removes the longer one.
%$k$ ($k$ is user-settable with a default value 5 as used in our
%experiments) head nodes, and removes the longer one.

%\item
\textbf{5. Filter Report With the Same Tail Methods from \CodeIn{Thread}.
\CodeIn{start()}
to the UI-accessing Method}. A method
can have multiple callers, so that method call chains with the same tail are likely
to just represent different ways to trigger the same error. This filter compares 
two reported method call chains that share the same 
tail from \CodeIn{Thread.start()} to the UI-accessing methods, and
removes the longer one.


%\end{enumerate}
\vspace{1mm}

Among the above 5 filters, filters 2 and 3 are sound
in that they will not filter real bugs, and other 3 filters
are based on heuristics. However, as we will show in
our experiments, these filters work remarkably well in practice (Section~\ref{sec:filters}).


\subsection{Instantiation for Different Frameworks}
\label{sec:platforms}

We instantiated our error detection technique for four popular GUI frameworks:
SWT, Eclipse plugin, Swing, and Android.
The major framework-specific parts, corresponding to
lines 3 -- 5 in Figure~\ref{fig:detectalgorithm}, are identifying
\textbf{call graph entry nodes}, \textbf{UI-accessing nodes},
and \textbf{safe UI methods} for each framework.

%For each framework, we customize the \textit{call graph entry nodes},
%\textit{UI-accessing nodes}, and \textit{safe UI methods} on lines 3 -- 5 of the
%algorithm in 

%For the sake of efficiency, they are all using the single thread model.

%Why these platforms? popularity? account for xxx\% of the GUI. 

%customizing for: entry points, starting points, error checking, thread
%safe UI methods, what is the event dispatching thread?

\subsubsection{SWT}

%SWT is an open source widget toolkit for Java designed to provide efficient,
%portable access to the GUI facilities of the operating systems
%on which it is implemented.
 We instantiated our technique for SWT applications as follows:

%starts from its main method.
%By default, the thread that the main method executes is the UI thread. Thus, we instantiate
%our technique as follows:

\begin{itemize}

\item \textbf{Call graph entry nodes: } the main method. Like a normal Java program,
a SWT desktop application has a single main method as the entry point. By default,
the main method is executed in the UI thread after the GUI
is initialized.

\item \textbf{UI-accessing nodes: } the \CodeIn{Display.checkWidget}
and \CodeIn{Display.} \CodeIn{checkDevice} methods. SWT uses the above
two methods to explicitly check thread accesses at runtime.
Any methods for manipulating GUIs object must call (one of) these two methods
 to determine whether the current thread is the UI thread or not.
%Thus, we treat nodes (in both user code and framework code) corresponding to the methods
%calling these two methods as UI-accessing nodes.
%must be invoked
%in the UI thread and as
%UI-accessing nodes.
 %methods to check whether the current thread is the UI thread or not. Thus,
%we treat all such methods that must be accessed in UI thread as the UI-accessing nodes.
% any
%methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe UI methods: } SWT provides two helper methods (\CodeIn{Display.\\asyncExec}
and \CodeIn{Display.syncExec}) to execute code (a)synchro-
nizedly on the UI thread.
 We treat these two methods as safe UI methods, since invoking
them from any thread 
%are generally considered to be safe and
will not cause an invalid thread access error.

\end{itemize}

\subsubsection{Eclipse plugin}

We instantiated our technique for Eclipse plugin as follows:

%Unlike a SWT desktop application, an eclipse plugin, though is developed in SWT,
%has no single main method. Instead, (XXX) it extends certain extension points
%exposed by the eclipse framework, and eclipse will XXX. To instantiate our
%technique for the Eclipse plugin environment, we need to redefine the
%call graph entry points.

\begin{itemize}

\item \textbf{Call graph entry nodes: } all overridden SWT
GUI event handling methods in user code. An Eclipse plugin is built
on top of the SWT framework. However, unlike a SWT desktop application,
an Eclipse plugin does not have a main method as a single program entry point.
Instead, it extends extension points provided by the Eclispe framework to
implement functionalities. When a plugin starts, Eclipse
calls back the overridden methods to handle the
upcoming events. All SWT GUI event handling methods (i.e., the overriden
methods in the class that implements \CodeIn{org.eclipse.swt.internal.SWTEvent-\\Listener}) are
always called back from the UI thread, thus are used as call graph entry nodes.


\item \textbf{UI-accessing nodes} and \textbf{Safe UI methods} are the same as SWT.

\end{itemize}

\subsubsection{Swing}


A Swing application has a single main method, but contains three kinds of
threads: \textit{initial thread} that executes initial application code from the main method,
the \textit{UI thread}, where all GUI manipulation code is executed,
and the \textit{worker thread} where time-consuming background tasks are executed.
After a Swing program starts, its initial thread exits and the UI thread takes charge
of the application and starts to execute all event-handling code or spawns new worker threads. 
We instantiated our technique for Swing as follows:
%XXXX Therefore, we can not directly
%use the main method as the call graph entry point, since it is not invoked
%by the UI thread. We customize our technique for Swing as follows:

\begin{itemize}

\item \textbf{Call graph entry nodes:} all overridden Swing GUI event handling
methods in user code. Those event handling methods are always
called back from the UI thread, thus are used as call graph entry nodes.

\item \textbf{UI-accessing nodes:} %as stated in Swing's documentation,
all methods defined in each Swing GUI class except for three thread-safe
methods: \CodeIn{repaint()}, \CodeIn{revalidate()}, and \CodeIn{invalidate()}.

%methods in Swing GUI classes are not thread safe with three exceptions (\CodeIn{repaint()},
%\CodeIn{revalidate()}, and \CodeIn{invalidate()}). Thus, we
%treat nodes corresponding to those thread unsafe methods %in each GUI class
%as UI-accessing nodes.

\item \textbf{Safe UI methods: }  Swing's two helper methods
(\CodeIn{SwingUtilities.} \CodeIn{invokeLater} and \CodeIn{SwingUtilities.invokeAndWait}) that execute code on the UI thread.

\end{itemize}

\subsubsection{Android}

Android is a Java-based platform for embedded or mobile devices. 
An Android program does not have a single entry point but can
rather use parts of other Android applications on-demand and can require their
services by calling corresponding event handlers, directly or through the
operating system. In particular, Android applications use \textit{activities}
as code interacting with the user through a visual interface. GUI event handlers
are handled in an activity.
We instantiated our technique for Android programs as follows:
%, with some notable exceptions such as the
%lifecycle of activities.

%An XML \textit{manifest file} registers the components of an application. Other XML
%fies describe the visual layout of the activities. Activities \textit{inflate}
%layout files into
%visual objects (a hierarchy of views), through an \textit{inflater} provided by the An-
%droid library. This means that library or user-defined views are not explicitly
%created by new statements but rather inflated through \textit{reflection}. Library meth-
%ods such as \CodeIn{findViewById} access the inflated views.


\begin{itemize}

\item \textbf{Call graph entry nodes: }in an Android application,
an \CodeIn{Activity} object is created and manipulated by the UI thread. Thus, we treat
all public methods defined in the \CodeIn{Activity} class 
and any class in the user code that subclasses \CodeIn{Activity} as call graph entry nodes.
We also add all overridden Android GUI event handling methods in user
code as entry nodes, since they are also called back from the UI thread.

\item \textbf{UI-accessing nodes: }the \CodeIn{ViewRoot.checkThread} method.
Like SWT, Android explicitly checks whether
the current thread is a UI thread or not before accessing a GUI object via
the \CodeIn{ViewRoot.checkThread} method.
%method. This method is the only place where Android checks
%whether the current thread is the UI thread or not. Thus, any
%methods that calls the checking method must be invoked in the UI thread.

\item \textbf{Safe UI methods: } two helper methods (\CodeIn{View.post}
and \CodeIn{View.postDelay}) that execute code on the UI thread. 
Invoking them on any thread will not cause an invalid thread access error.
%Invoking these two methods are generally considered to be safe, and would not
%cause an invalid thread access error.

\end{itemize}


Instantiating our general technique to  a specific framework
requires moderate human effort. We wrote around 500 lines of Java code in total to achieve
the above four instantiations.
