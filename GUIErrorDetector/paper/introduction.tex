\section{Introduction}
\label{sec:introduction}

End-user satisfaction and retention of a software application
 are largely dependent on the usability and correctness of
its GUIs.

To make the GUI more responsive and utilize multi-core computation,
GUI applications often spawn separate threads to handle time-consuming
operations in the background, such as expensive computation, I/O tasks,
and network requests. This permits the GUI to respond to new events
even before the lengthy task completes.



\subsection{The Single-thread Rule}

Many popular GUI frameworks such as Swing~\cite{swing},
SWT~\cite{swt}, Android~\cite{android},
Qt~\cite{qt}, MacOS Cocoa~\cite{macos},
and X Windows~\cite{xwindow}
adapt the \textit{single-thread rule}:

\vspace{-2mm}

\begin{quote}
All GUI objects, including visual components and data models, must be
 accessed exclusively from the \textit{event dispatching thread}.
\end{quote}

\vspace{-2mm}

The \textit{event dispatching thread}, also called the \textit{UI thread}, is a single
special thread initialized by the GUI framework, where all event-handling code
is executed. All code that interacts with GUI objects must also
execute on that thread.  There are several advantages to the single-thread rule:

\begin{itemize}

\item GUI developers do not need an in-depth
understanding of concurrent programming. A GUI framework in which all GUI objects
fully support multithreaded access can be difficult to extend, particularly
for developers who are not expert at threads programming.

\item GUI events are dispatched in a predictable order from the same event queue.
In contrast, in a GUI framework without adapting the single-thread rule where GUI objects 
support multithreaded access, any component changes can be interleaved with event
processing at the whim of the thread scheduler. This makes program behavior comprehension hard,
 and comprehensive testing difficult or impossible. 

\item The single-thread rule incurs less overhead.
A GUI framework that attempts to carefully lock critical sections can spend a substantial
amount of time and space managing locks. Whenever the framework calls a method that might
be implemented in client code (for example, any public or protected method in a public class),
the framework must save its state and release all locks so that the client code can grab locks
if necessary. When GUI objects return from the method, the framework must re-grab their locks and
restore states. Therefore, all applications using the framework will bear the cost of this, even though most
applications do not require concurrent access to the GUI.

\end{itemize}

%Single-threaded GUI frameworks are not unique to Java; ,
%and many others are also single-threaded.

\subsection{The Invalid Thread Access Error}

The single-thread rule pushes a burden back on GUI application developers,
who must ensure all GUI objects are accessed by the UI thread.

In a multithreaded GUI application, the single-thread rule can be
easily violated since a spawned non-UI thread often needs to update
the GUI  after its  task is finished.
For example, a server program can get requests from other programs
that might be running on different machines. These requests can come at any time,
and they result in one of the server's methods being invoked in some thread.
After handling the request, the GUI-update code that displays the response must be executed on the UI-thread.
If not, an \textit{invalid thread access error} will occur. In practice, such
invalid thread access error is \textit{frequent}, \textit{pervasive}, and \textit{severe}.
%and \textit{difficult to avoid}.

Take the popular Standard Widget Toolkit (SWT) GUI framework as an example. 
The invalid thread access error is one of the top 3 bugs in developing a SWT application, and is
the source of many relevant concurrency bugs~\cite{top3bugs}.
A Google search for ``SWTException:Invalid thread access''  returns over 11,800 entries,
consisting of numerous bug reports, forum posts, and mailing list threads on
this problem. Eclipse, the IDE for Java development, is built on top of SWT.
Searching for ``SWTException:Invalid thread access'' in Eclipse's bug repository
and discussion forum returns over 2732 bug reports and 351 distinct threads, respectively. 
We manually studied all 156 \textit{confirmed} distinct bug reports, and 
found this error has been reported in at least 20 distinct eclipse projects
and 40 distinct eclipse components. Even after over 10 years of active development,
a recent release of Eclipse still contains this error (bug id: 333533, reported in 01/2011).
 Furthermore, many reported  errors are non-trivial, and it is unintuitive
to fix them. Developers usually need non-local reasoning to find the specific
UI interactions that can trigger the bug;  it even took developers 2 years
to fix bug: 51757 and verify the patch. In addition, the invalid thread access error
is UI-relevant and user-perceivable; it cannot be recovered by the program itself
and often terminates the whole application. In many circumstances as described in the bug reports,
users can only restart the application to recover from the error.




\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

     /* In class: org.mozilla.gecko.gfx.LayerView */
68.  public LayerView(Context context, LayerController controller) \{
69.     super(context);
        ....
73.     mRenderer = new LayerRenderer(this);
74.     setRenderer(mRenderer);
        ...
     \}

     /* In Android's lib class: android.opengl.GLSurfaceView */
272. public void setRenderer(Renderer renderer) \{
        ...
282.    mGLThread = new GLThread(renderer);
283.    mGLThread.start();   
     \}

     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.    gl.glViewport(0, 0, width, height);
222.    mView.setViewportSize(new IntSize(width, height));
     \}

\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:androiderror} A real
bug reported on 11/17/2011 in Mozilla firefox release 10.0.a.rc3
for the Android platform (bugzilla ID: 703256). \CodeIn{LayerView}'s constructor
calls method \CodeIn{setRender} that
spawns a new thread at line 283. The new thread calls back method
\CodeIn{onSurfaceChanged} that access GUI objects at line 222, and
causes an invalid thread access error.
Our tool
can find this error and generate a warning as shown in
Figure~\ref{fig:report}.
}} %\vspace{-5mm}
\end{figure}

The invalid thread access error is not unique to the SWT framework. Other recent GUI frameworks
like Android also suffer from similar problems. For example, 
Figure~\ref{fig:androiderror} shows a recently reported bug on Android version of Mozilla Firefox.
In Figure~\ref{fig:androiderror}, \CodeIn{LayViewer}'s constructor calls the
\CodeIn{setRender} method (line 74), which spawns a new thread (line 283).
This newly created, non-UI thread calls back the \CodeIn{onSurfaceChanged} method that
accesses the GUI objects at line 222, causing an invalid thread access error.
Compared to other reported errors, this bug is even more difficult to note, 
since the code that spawns a new thread inside the \CodeIn{setRender} method is
in an Android library whose source code may not be available to developers.

%It may work during development, but like most concurrent bugs, you'll start to see weird exceptions come up that seem completely unrelated, and occur non-- usually spotted AFTER you've shipped by real users. Not good.

%Also, you've got no confidence that your app will continue to work on future CPUs with more and more cores - which are more prone to encountering weird threading issues due to them being truely concurrent rather than just simulated by the OS.


\subsection{Finding Invalid Thread Access Errors}
\label{sec:finding}

Invalid thread access errors have significantly affect the
usability of GUIs, but they have not been thoroughly studied in
the context of multithreaded GUI applications. To ensure GUIs
behave correctly, effective techniques must be developed to alleviate this problem.

Software testing, the most widely used method to ensure program correctness,
is insufficient to detect such errors. The space of possible interactions
with a GUI is enormous, in that each sequence of GUI events can result in
a difficult state, and each GUI event may need to be evaluated in all of
these states. It is almost impossible for testing to cover every possible
state. In fact, a widely-used software system like Eclipse
often has a well-designed test suite that achieves fairly high statement coverage;
but many paths executed by bug-triggering UI sequences are still not covered.

%Program refactoring~\cite{Mens:2004}, another popular way to improve software quality,
%is also inadequate to eliminate this error. 

%One way to find such invalid thread access error is to check every GUI object
%accessing code to see whether

A standard way to fix an
invalid thread access error is to replace direct GUI object accessing code 
with asynchronized message passing, to ensure a GUI object is accessed in
the UI thread. For example, to fix the bug in Figure~\ref{fig:androiderror},
a developer would wrap line 222 inside a \CodeIn{post} message passing method\footnote{The
\CodeIn{post} method in class \CodeIn{android.widget.View} is a
a standard way to send messages to the UI-thread.}, as follows:


\begin{CodeOut}
\begin{alltt}
     /* In class: org.mozilla.gecko.gfx.LayerRenderer */
220. public void onSurfaceChanged(GL10 gl, int width, int height) \{
221.     gl.glViewport(0, 0, width, height);
         \textbf{mView.post(new Runnable() \{}
             \textbf{public void run() \{}
222.             mView.setViewportSize(new IntSize(width, height));
             \textbf{\}}
         \textbf{\});}
     \}
\end{alltt}
\end{CodeOut}

One may wonder that a simple analysis to check whether every GUI object
accessing code has been wrapped by (a)synchronized message passing may
be capable to find invalid thread errors. However, such an approach is problematic,
because not every GUI object access needs to be wrapped by a message passing
method, e.g., methods that are only called from UI-thread can safely
access any GUI object. On the other hand, using asynchronized message passing has no timing
guarantee. It is entirely possible that, in some cases, a GUI object has already been
disposed before the message sent to arrives, causing other bugs. 
Thus, programmers can not use it everywhere to wrap all GUI object accessing code.
In our evaluation on real world programs, we found this simple analysis 
can not be used in practice: it issued
an unacceptable number of false positives and redundant warnings.


%program transformation to wrap
%every possible UI-accessing operation with asynchronized message passing
%may avoid the invalid thread error. However, such an approach is problematic,
%because using asynchronized message passing has no timing
%guarantee. It is entirely possible that, in some cases, a GUI object has already been
%disposed before the message sent to arrives, causing other bugs. Thus, programmers can not use
%it everywhere; instead, they must choose carefully to put it in appropriate places
%with extreme caution. This makes invalid thread errors even harder to avoid,
%and demands a proactive technique to detect them.

%Here are a few reasons, first, for the sake of efficiency, UI must use multi-thread to perform updates and processing user requests; second, there is no language level enforcement to prevent this error; and third, programmers often forget corner cases like an event listener that may init a non-UI thread to update a UI component.
%Furthermore, asyncExec has no timing guarantee, and programmers can not use it everywhere

This paper uses static analysis to find such potential errors.
Static analysis has two advantages while compared to dynamic approaches such as
 testing. First, a static analysis can explore every path of the program without
executing the code, and without the need for a test suite.
Second, a static analysis can verify the code: if it
reports no warnings, the code is guaranteed to be bug-free. 


\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}

   org.mozilla.gecko.gfx.LayerView.<init>(Context;LayerController)
-> android.opengl.GLSurfaceView.setRenderer(GLSurfaceView\$Renderer;)
-> java.lang.Thread.start()
-> android.opengl.GLSurfaceView\$GLThread.run()
-> android.opengl.GLSurfaceView\$GLThread.guardedRun()
-> org.mozilla.gecko.gfx.LayerRenderer.onSurfaceChanged(GL10;II)
-> org.mozilla.gecko.gfx.LayerView.setViewportSize(IntSize;)
...
-> android.view.ViewRoot.checkThread()
\end{alltt}
\end{CodeOut}
\vspace*{-2.0ex} \Caption{{\label{fig:report} A report
generated by our tool to reveal the potential error in
Figure~\ref{fig:androiderror}. This report indicates a 
full method call chain that causes the error. $\rightarrow$ represents
the call relationship
between methods, and \CodeIn{checkThread} is an Android library
method  that checks whether the current thread is the
event dispatching thread before accessing a GUI object.
}} %\vspace{-5mm}
\end{figure}

In our static analysis, we formulate finding invalid thread access as a call graph reachability
problem. Given a call graph, our technique traverses
every possible paths from its entry nodes, checking whether
there exists a path to access a GUI object from a non-UI thread. If 
a suspicious path is found,
the static analysis issues a potential warning in the form of a method
call chain from the starting point, serving as the contextual information
for developers to understand the error.
As an example, Figure~\ref{fig:report} shows a report produced
by our static analysis for the buggy code in Figure~\ref{fig:androiderror}.
This report clearly indicates how a new, non-UI thread is spawned and
accesses GUI objects. 
The generated report is a great starting point for the developers, who can
inspect the method call chain, understand how the error
is triggered, and then determine if it is a real bug.

Our static analysis is independent of the call graph construction algorithms.
Given a sound call graph, our analysis is sound in that it does
not miss true positives. We note, however, that computing a sound
call graph with acceptable precision for GUI applications in the presence of reflection
is non-trivial.
Existing call graph construction algorithms such as RTA~\cite{rta}
and k-CFA~\cite{kcfa}
fails to build a sufficiently complete call graph, due to their limitations
to reason about reflections.  To alleviate this problem,
we present a method to build reflection-aware call graph, and
also compare its usefulness with existing call graph construction algorithms in
our experiments. We also note that static analysis may report false positives due to its
conservative nature, or multiple warnings that actually correspond
to the same error. To alleviate such limitations, we devise a set
 of heuristics to filter likely false positives and redundant warnings.

\subsection{Technique Instantiation and Evaluation}


We instantiated our technique for four popular GUI frameworks namely SWT,
eclipse plugin environment, Java Swing, and Android. 
Swing and SWT are unquestionably 
two dominating GUI frameworks in developing desktop Java applications.
Eclipse and its plugin development environment is the de-facto standard
IDE for Java. Android is the No. 1 platform for
developing mobile applications with market share 56\% as of Sep 2011.
Although our technique is generally applicable for GUI
frameworks adapting the single-thread rule, a specific framework
may have its own treatment of \textit{UI thread} and \textit{call graph
entry nodes}. Thus, we must explicitly identify those framework-specific
parts in our prototype tool implementation.

%Applications built on top of different GUI frameworks have different
%treatment of \textit{UI thread} and \textit{call graph entry nodes}.
%Instantiating the general technique for each framework only requires few
%human effort. The primary framework-specific part is to specify
%the \textit{UI thread} and \textit{call graph entry nodes}.


We implement an invalid thread error detection tool that supports
the above four GUI frameworks. Our tool works in a fully-automatic,
push-button manner, and scales to realistic programs.
We evaluate our implementation on XXX subjects from four different
frameworks over XXX LOC. The experiment results demonstrate
that: our technique is effective (it found XXX real-world errors
on all supported frameworks, and produced significantly less
false positives and redundant warnings than the simple analysis);
our reflection-aware call graph construction algorithm is
critical in finding errors in Android applications,
%graph construction algorithm is useful (XXX it improves both completeness
%and precision over the existing algorithms), 
and our proposed
heuristics are useful (it significantly reduces the number of
false positives and redundant warnings).




\subsection{Contributions}

This paper makes the following contributions:

\begin{itemize}
\item \textbf{Problem.} We are the \textit{first} to address
the invalid thread access error detection problem in the context of multithreaded GUI applications.
%, and formulate it
%as a call graph reachability problem.

\item \textbf{Technique.} We formulate finding
the invalid thread access error as a call graph reachability problem,
and present a general error detection technique.
In particular, to deal with the unique features in
multithreaded GUI programs, we propose a reflection-aware
call graph construction method. (Section~\ref{sec:technique}).

\item \textbf{Implementation.} We implement our technique, and
instantiate it for four
popular GUI platforms: SWT, eclipse plugin, Swing, and Android (Section~\ref{sec:implementation}). Our
tool implementation is publicly available at:
\url{http://guierrordetector.googlecode.com}

\item \textbf{Evaluation.} We performed an experiment on XXX subjects
from 4 different platforms over XXX LOC to show the usefulness
of the proposed technique (Section~\ref{sec:evaluation}).

\end{itemize}

