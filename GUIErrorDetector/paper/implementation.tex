\section{Implementation}
\label{sec:implementation}

We implemented the proposed technique using the WALA framework~\cite{walatutorial}.
Our prototype tool takes Java bytecode as input, works in a fully
automatic and push-button way to detect potential invalid thread access
errors, and scales to realistic programs.  

%Optionally, users may specify additional heuristic filters (Section~\ref{sec:heuristic}) %to guide call graph traverse
%, and annotate call relationships for native methods (Section~\ref{sec:annotation}).

Our current implementation supports four widely-used GUI frameworks, namely
SWT, Eclipse plugin development, Swing, and Android.
%, including dependent libraries such as \CodeIn{rt.jar} and \CodeIn{android.jar}.
%into analysis. 
We implemented the reflection-aware call graph construction
 algorithm (Section~\ref{sec:cg}) using WALA's \textit{bypass logic}.
Unlike similar tools~\cite{Payet:2011:SAA:2032266.2032299}, our tool
does not require a separated
pass of program instrumentation; instead, it
parses the configuration file in an Android application,
and then intercepts the call graph construction
process on-the-fly to replace all reflection calls with object creation statements.
Since Android applications are often fully encrypted and shipped in Dalvik
bytecode as a single apk file, our tool first uses
android-apktool~\cite{apktool} to
decrypt the apk file, and then uses the 
ded translator~\cite{ded} to convert
Dalvik bytecode to Java bytecode before feeding to WALA.  The Android system
library (i.e., \CodeIn{android.jar}) uses many ``stub'' classes as
placeholders for the sake of efficiency. We manually re-compiled the whole
\CodeIn{android.jar} from its source code and replaced all ``stub'' classes
with real class files.


%Static Single Assignment (SSA) transformation to get limited flow sensitivity
