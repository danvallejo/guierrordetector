
\tinystep
\tinystep
\section{Implementation}
\label{sec:implementation}

We instantiated the proposed technique for four widely-used
GUI frameworks, namely SWT, Eclipse plugin development, Swing, and Android;
and implemented an error detection tool.

%We implemented the proposed technique using the WALA framework~\cite{walatutorial}.
%Our prototype tool takes Java bytecode as input, 
%automatically detects potential invalid thread access
%errors, and scales to realistic programs.  


\tinystep


\subsection{Instantiation for Different Frameworks}
\label{sec:platforms}

When instantiating our error detection technique for different
frameworks, the major framework-specific parts, corresponding to
lines 3 -- 5 in Figure~\ref{fig:detectalgorithm}, are identifying
\textbf{call graph entry nodes}, \textbf{UI-accessing nodes},
and \textbf{safe UI methods} for each framework.

\tinystep
\subsubsection{SWT}

 We instantiated our technique for SWT applications as follows:

\begin{itemize}
\smallstep

\item \textbf{Call graph entry nodes: } the main method. Like a normal Java program,
a SWT desktop application has a single main method as the entry point. By default,
the main method is executed in the UI thread after the GUI
is initialized.

\smallstep

\item \textbf{UI-accessing nodes: } the \CodeIn{Widget.checkWidget}
and \CodeIn{Display.} \CodeIn{checkDevice} methods. SWT uses the above
two methods to explicitly check whether the current thread is a UI thread,
and throw a \CodeIn{RuntimeException} if the checking fails.
%thread accesses at runtime.
%Any methods for manipulating GUIs object must call (one of) these two methods
% to determine whether the current thread is the UI thread or not.
\smallstep

\item \textbf{Safe UI methods: } \CodeIn{Display.asyncExec}
and \CodeIn{Display.syncExec}. SWT provides these two methods
to execute code (a)synchro- nizedly on the UI thread.

\end{itemize}

\tinystep
\subsubsection{Eclipse plugin}

We instantiated our technique for the Eclipse plugin development framework as follows:

\smallstep

\begin{itemize}

\item \textbf{Call graph entry nodes: } all user code methods that override
 SWT GUI event handling methods. Eclipse
calls back the overridden methods to handle the
events. All SWT GUI event handling methods (i.e., the overriden
methods in the class that implements \CodeIn{org.eclipse.swt.internal.SWTEvent-\\Listener}) are
always called back from the UI thread.
%, thus are used as call graph entry nodes.

\smallstep

\item \textbf{UI-accessing nodes} and \textbf{Safe UI methods} are the same as SWT.

\end{itemize}

\tinystep
\tinystep
\subsubsection{Swing}

A Swing application has a single main method, but contains three kinds of
threads: \textit{initial thread} that executes initial application code from the main method,
the \textit{UI thread}, where all GUI manipulation code is executed,
and the \textit{worker thread} where time-consuming background tasks are executed.
After a Swing program starts, its initial thread exits and the UI thread takes charge
of the application and starts to execute all event-handling code or spawns new worker threads. 
We instantiated our technique for Swing as follows:

\begin{itemize}

\item \textbf{Call graph entry nodes:} all user code methods that override
Swing GUI event handling methods. Those event handling methods are always
called back from the UI thread.

\smallstep

\item \textbf{UI-accessing nodes:} %as stated in Swing's documentation,
all methods defined in each Swing GUI class except for three thread-safe
methods: \CodeIn{repaint()}, \CodeIn{revali-\\date()}, and \CodeIn{invalidate()}.

\smallstep

\item \textbf{Safe UI methods: } 
\CodeIn{SwingUtilities.}\CodeIn{invokeLater} and \CodeIn{Swing-\\Utilities.invokeAndWait} that execute code on the UI thread.

\end{itemize}

\smallstep

\subsubsection{Android}

Android is a Java-based platform for embedded or mobile devices. 
An Android program does not have a single entry point.
%but can
%rather use parts of other Android applications on-demand and can require their
%services by calling corresponding event handlers, directly or through the
%operating system. In particular,
%Android applications 
It uses \textit{activities}
(i.e., instances of the \CodeIn{Activity} class)
to interact with users through a visual interface and handle GUI events.
We instantiated our technique for Android programs as follows:


\begin{itemize}

\item \textbf{Call graph entry nodes: }in an Android application,
an \CodeIn{Activity} object is created and manipulated by the UI thread. Thus, we treat
all public methods defined in the \CodeIn{Activity} class 
and any overriding definitions in its subclasses as call graph entry nodes.
We also add all user code methods that override Android GUI event handling methods
as entry nodes, since they are called back from the UI thread.

\smallstep

\item \textbf{UI-accessing nodes: }the \CodeIn{ViewRoot.checkThread} method.
Like SWT, Android explicitly performs runtime checking before accessing
a GUI object via the \CodeIn{ViewRoot.checkThread} method. If the current
thread is a non-UI thread, the \CodeIn{ViewRoot.checkThread} method throws
a \CodeIn{RuntimeException}.

\smallstep

\item \textbf{Safe UI methods: } \CodeIn{View.post}
and \CodeIn{View.postDelay} that execute code on the UI thread. 

\end{itemize}

\tinystep

Instantiating our general technique to  a specific framework
requires moderate human effort. We wrote around 500 lines of Java code in total to achieve
the above four instantiations.

\subsection{Implementation Details}

We implemented our error detection tool using
the WALA framework~\cite{walatutorial}.
Our tool takes Java bytecode as input, 
automatically detects potential invalid thread access
errors, and scales to realistic programs.  
We implemented the reflection-aware call graph construction
 algorithm (Section~\ref{sec:cg}) using WALA's \textit{bypass logic}.
Unlike existing tools~\cite{Payet:2011:SAA:2032266.2032299}, our tool
does not require a separate pass for program instrumentation; instead, it
parses the configuration file in an Android application,
and then intercepts the call graph construction
process on-the-fly to replace all reflection calls with object creation statements.
Since Android applications are often fully encrypted and shipped in Dalvik
bytecode as a single apk file, our tool first uses
android-apktool~\cite{apktool} to
decrypt the apk file, and then uses the 
ded translator~\cite{ded} to convert
Dalvik bytecode to Java bytecode before feeding to WALA.  The Android system
library (i.e., \CodeIn{android.jar}) uses many ``stub'' classes as
placeholders for the sake of efficiency. We manually re-compiled 
\CodeIn{android.jar} from its source code, so it contains real
class files rather than stubs.
