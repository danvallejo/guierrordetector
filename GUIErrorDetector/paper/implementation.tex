\section{Implementation}
\label{sec:implementation}

We implemented the proposed technique using the WALA framework~\cite{walatutorial}.
Our prototype tool takes Java bytecode as inputs, works in a fully
automatic and push-button way to detect potential invalid thread access
errors, and scales to realistic programs.  
Optionally, users may specify additional heuristics to guide call graph
traverse, and annotate call relationships for native methods (Section~\ref{sec:heuristic}).

Our current implementation supports four widely-used GUI frameworks, namely
SWT, Eclipse plugin development environment, Java Swing, and Android.
Our implementation handles all of the Java language, and also takes
all dependent libraries (e.g., \CodeIn{rt.jar} and \CodeIn{android.jar})
into analysis. We implement the reflection taming algorithm (Section~\ref{})
using WALA's \textit{bypass logic}. Our tool parses the configuration file
in an Android application and modifies the bytecode to replace all
reflection calls with object creation instructions.
Since Android applications are often fully encrypted and shipped in Dalvik
bytecode as a single apk file, our tool first uses
android-apktool\footnote{\url{http://code.google.com/p/android-apktool/}} to
decrypt the apk file, and then uses the 
ded translator~\cite{Enck:2011:SAA:2028067.2028088} to convert
Dalvik bytecode to Java bytecode before feeding to WALA.  The Android system
library (i.e., \CodeIn{android.jar}) uses many ``stub'' classes as
placeholder for the sake of efficiency. We manually re-compiled the whole
\CodeIn{android.jar} from its source code by replacing all ``stub'' classes
with real class files.


%Static Single Assignment (SSA) transformation to get limited flow sensitivity
