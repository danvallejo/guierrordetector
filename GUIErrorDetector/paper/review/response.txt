Thanks for your helpful comments.

We agree with reviewer #1 and #2 that this paper addresses one kind of
error (i.e., the invalid thread access error) in GUI application.
However, as shown in Sec 1.2, this error is important, pervasive, and
severe in developing multithreaded GUI applications, and there are no
effective solutions yet. As part of this paper's contribution is
identifying the invalid thread access problem. We keep our solution
simple to make it generally applicable and sufficient to detect many
real errors [*is such argument useful?*], instead of focusing on finding
certain sophisticated errors. On the other hand, the core idea of
formulating invalid thread access error detection as source-sink
reachability analysis can be extended to other domains, such as finding
Null pointer errors (does a null pointer reach a dereference?), security
vulnerability (does a tainted input reach a security-critical operation?),
or IO-related errors (e.g., does a closed file reach a read operation?).

Reviewer #1 requests additional clarification for Sec. 4.3.4. Here,
by "sound" graph visit algorithm, we mean one that will not miss any true
error path. Given a conservative call graph, BFS and DFS are not sound,
because BFS returns the shortest path and DFS returns the first path it
sees when searching in deep of the graph.  Both of them may return the
false positive paths or miss the true error paths.  We agree that exhaustive
search may not report the exact error path as it appears at runtime, since
static graph traversal cannot precisely reason about the number of loops a
real program execution may take. However, exhaustive path enumeration is
still sound in that it will not miss error paths, since it lists all
non-cyclic paths from a starting node to UI-accessing nodes via thread
spawning node (i.e., Thread.start()), even if a UI-accessing or thread
spawning node is in a cycle. [*I am not quite satisfied with this argument,
but not sure how to make it better*]
